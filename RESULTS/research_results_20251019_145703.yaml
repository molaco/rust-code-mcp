- title: Embedding Generation Strategy
  query: 'Analyze how each project generates embeddings for code. Rust-code-mcp uses local fastembed with all-MiniLM-L6-v2 model. Claude-context supports OpenAI, VoyageAI, and other external APIs. Compare the trade-offs: cost, latency, privacy, accuracy, and dependency requirements.'
  response_file: ./RESULTS/research_result_4_20251019_144148.yaml
  focus:
  - Embedding model choices and capabilities
  - Local vs API-based generation
  - Cost implications (free local vs paid APIs)
  - Privacy and data handling
- title: Hybrid Search Implementation
  query: Compare the hybrid search implementations in both projects. Both claim to use BM25 + vector search, but examine the specific algorithms, fusion methods, and ranking strategies. Rust-code-mcp uses RRF (Reciprocal Rank Fusion) for result merging - investigate what fusion approach claude-context uses and how the implementations differ.
  response_file: ./RESULTS/research_result_3_20251019_144148.yaml
  focus:
  - BM25 implementation details
  - Vector search algorithms and similarity metrics
  - Result fusion and ranking methods
  - Query processing and optimization
- title: Performance and Scalability
  query: Research the performance characteristics and scalability claims of both projects. Rust-code-mcp targets 1M+ LOC codebases with <200ms p95 query latency (target, not benchmarked). Claude-context claims 40% token reduction. Compare indexing times, query latencies, memory usage, and maximum supported codebase sizes based on documentation and code.
  response_file: ./RESULTS/research_result_7_20251019_144148.yaml
  focus:
  - Indexing speed and throughput
  - Query latency and response times
  - Memory footprint and resource usage
  - Maximum codebase size supported
- title: Core Architecture Comparison
  query: Compare the overall system architecture of rust-code-mcp with claude-context. Examine how each handles the flow from code ingestion to search results. Claude-context uses Node.js with Milvus/Zilliz Cloud (remote vector DB), while rust-code-mcp uses Rust with embedded Qdrant. Analyze the trade-offs between embedded vs cloud-based approaches, language choices, and architectural decisions.
  response_file: ./RESULTS/research_result_1_20251019_144148.yaml
  focus:
  - Vector database strategy (embedded Qdrant vs Milvus/Zilliz Cloud)
  - Runtime and language differences (Rust vs Node.js)
  - Storage architecture (local-first vs cloud-first)
  - Deployment and configuration complexity
- title: Code Chunking Mechanisms
  query: Examine the code chunking strategies used by rust-code-mcp versus claude-context. Rust-code-mcp uses tree-sitter for symbol-based semantic chunking with context enrichment (imports, calls, docstrings). Investigate what chunking approach claude-context uses and whether it leverages AST parsing or simpler text-based methods.
  response_file: ./RESULTS/research_result_5_20251019_144148.yaml
  focus:
  - Chunking granularity (symbol-based vs text-based)
  - AST/parser usage (tree-sitter vs alternatives)
  - Context enrichment strategies
  - Chunk overlap and boundary handling
- title: MCP Tool Interface Analysis
  query: Investigate the MCP tools exposed by rust-code-mcp (8 tools) versus claude-context (4 tools). Compare the tool signatures, input parameters, and output formats. Claude-context offers index_codebase, search_code, clear_index, and get_indexing_status. Document which capabilities overlap and which are unique to each implementation.
  response_file: ./RESULTS/research_result_2_20251019_144148.yaml
  focus:
  - Tool count and purpose comparison
  - Indexing interface differences
  - Search capabilities (keyword vs semantic vs hybrid)
  - Additional analysis tools (call graphs, complexity, references)
- title: Incremental Indexing Capabilities
  query: Compare incremental indexing implementations. Rust-code-mcp uses SHA-256 file hashing with sled metadata cache for change detection (10x speedup on unchanged files). Investigate whether claude-context supports incremental updates, how it detects file changes, and what performance characteristics it achieves.
  response_file: ./RESULTS/research_result_6_20251019_144148.yaml
  focus:
  - Change detection mechanisms
  - Reindexing performance and efficiency
  - Metadata persistence strategies
  - File watching and auto-update support
