# MCP Tools Comparison: rust-code-mcp (8 tools) vs claude-context (4 tools)
comparison_date: 2025-10-19
rust_code_mcp_version: Phase 7 Complete
claude_context_version: "@zilliz/claude-context-mcp latest"

# ==============================================================================
# TOOL INVENTORY
# ==============================================================================

rust_code_mcp_tools:
  count: 8
  tools:
    - search
    - read_file_content
    - find_definition
    - find_references
    - get_dependencies
    - get_call_graph
    - analyze_complexity
    - get_similar_code

claude_context_tools:
  count: 4
  tools:
    - index_codebase
    - search_code
    - clear_index
    - get_indexing_status

# ==============================================================================
# DETAILED TOOL SIGNATURES COMPARISON
# ==============================================================================

tool_signatures:

  # --------------------------------------------------------------------------
  # SEARCH/INDEXING TOOLS
  # --------------------------------------------------------------------------
  
  search_indexing:
    rust_code_mcp_search:
      tool_name: search
      description: "Search for keywords in text files within the specified directory"
      location: "src/tools/search_tool.rs:225-534"
      input_parameters:
        directory:
          type: String
          required: true
          description: "Path to the directory to search"
          validation: "Must be an existing directory"
        keyword:
          type: String
          required: true
          description: "Keyword to search for"
          validation: "Cannot be empty string"
      output_format:
        type: "CallToolResult with Content::text"
        structure: |
          "Search results ({count} hits):
          Hit: {file_path} (Score: {bm25_score})
          Hit: {file_path} (Score: {bm25_score})
          ..."
        error_cases:
          - "No text files found"
          - "Directory not found"
          - "Empty keyword"
      implementation_details:
        indexing_strategy: "On-demand with incremental updates"
        index_persistence: "Persistent Tantivy index in ~/.local/share/rust-code-mcp/"
        change_detection: "SHA-256 per-file hashing"
        caching: "Metadata cache with sled KV store"
        binary_detection: "Heuristic-based (null bytes, control chars, UTF-8 validation)"
        performance: |
          First index: ~50-100ms (2 files)
          Subsequent searches: <10ms (unchanged files skipped)
          After file change: ~15-20ms (selective reindexing)

    claude_context_index_codebase:
      tool_name: index_codebase
      description: "Index a codebase directory to enable semantic search"
      repository: "https://github.com/zilliztech/claude-context"
      input_parameters:
        path:
          type: string
          required: true
          description: "Absolute path to target directory"
          validation: "Must be absolute path"
        force:
          type: boolean
          required: false
          default: false
          description: "Re-index if already indexed"
        splitter:
          type: "'ast' | 'langchain'"
          required: false
          default: "ast"
          description: "Code splitter type (ast=tree-sitter, langchain=character-based)"
        customExtensions:
          type: "string[]"
          required: false
          description: "Additional file extensions like ['.vue', '.svelte']"
        ignorePatterns:
          type: "string[]"
          required: false
          description: "Patterns to exclude files/directories"
      output_format:
        type: "MCP CallToolResult"
        structure: |
          {
            "content": [{
              "type": "text",
              "text": "Started background indexing for codebase '{path}' using {splitter} splitter..."
            }]
          }
        async_behavior: "Returns immediately, indexing runs in background"
      implementation_details:
        indexing_strategy: "Asynchronous background indexing with progress tracking"
        index_persistence: "Milvus/Zilliz Cloud vector database"
        change_detection: "Merkle DAG (Directed Acyclic Graph)"
        caching: "Merkle snapshots in ~/.context/merkle/"
        code_parsing: "tree-sitter (primary) with langchain fallback"
        chunking: |
          AST mode: Function/class/method boundaries
          Langchain mode: 1000 chars, 200 overlap
        performance: |
          Change detection: milliseconds (Merkle root comparison)
          Directory-level skipping: 60-80% skip rate
          Hierarchical optimization: Yes

    claude_context_search_code:
      tool_name: search_code
      description: "Search the indexed codebase using natural language queries"
      input_parameters:
        path:
          type: string
          required: true
          description: "Absolute path to search directory"
        query:
          type: string
          required: true
          description: "Natural language search query"
        limit:
          type: number
          required: false
          default: 10
          maximum: 50
          description: "Maximum results to return"
        extensionFilter:
          type: "string[]"
          required: false
          description: "Filter by file extensions like ['.ts','.py']"
      output_format:
        type: "MCP CallToolResult"
        structure: |
          Found {count} results for query: "{query}"
          
          1. Code snippet ({language}) [{codebase}]
             Location: {relative_path}:{start_line}-{end_line}
             Rank: 1
             Context:
          ```{language}
          {code_snippet}
          ```
          
          2. Code snippet...
        features:
          - "Markdown formatting with code blocks"
          - "Line ranges displayed"
          - "Language auto-detection"
          - "Rank order (no scores shown)"
          - "Max 5000 chars per snippet"

    claude_context_clear_index:
      tool_name: clear_index
      description: "Clear the search index for a specific codebase"
      input_parameters:
        path:
          type: string
          required: true
          description: "Absolute path to directory"
      output_format:
        type: "MCP CallToolResult"
        structure: |
          Successfully cleared codebase '{path}'
          
          Remaining indexed codebases: {count}
          Currently indexing: {count}

    claude_context_get_indexing_status:
      tool_name: get_indexing_status
      description: "Get the current indexing status of a codebase"
      input_parameters:
        path:
          type: string
          required: true
          description: "Absolute path to check status"
      output_format:
        type: "MCP CallToolResult"
        states:
          indexed: |
            ‚úÖ Codebase is fully indexed
            
            Path: {path}
            Files indexed: {count}
            Total chunks: {count}
            Last indexed: {timestamp}
          indexing: |
            üîÑ Currently being indexed. Progress: {percentage}%
            
            Path: {path}
          failed: |
            ‚ùå Indexing failed
            
            Path: {path}
            Error: {message}
            
            Please try re-indexing with the index_codebase tool.
          not_found: |
            ‚ùå Not indexed. Use index_codebase tool to index this codebase first.
            
            Path: {path}

  # --------------------------------------------------------------------------
  # FILE OPERATIONS
  # --------------------------------------------------------------------------
  
  file_operations:
    rust_code_mcp_read_file_content:
      tool_name: read_file_content
      description: "Read the content of a file from the specified path"
      location: "src/tools/search_tool.rs:148-222"
      input_parameters:
        file_path:
          type: String
          required: true
          description: "Path to the file to read"
      output_format:
        type: "CallToolResult with Content::text"
        structure: |
          {file_content}
        special_cases:
          - "File is empty."
          - "The file appears to be a binary file..."
      implementation_details:
        binary_detection: |
          1. Check for null bytes
          2. Count control characters (>10% = binary)
          3. Validate UTF-8
          4. Check ASCII ratio (>80% = text)

    claude_context_equivalent:
      status: "No direct equivalent"
      notes: "claude-context focuses on indexed search, not raw file reading"

  # --------------------------------------------------------------------------
  # CODE ANALYSIS TOOLS (rust-code-mcp only)
  # --------------------------------------------------------------------------
  
  code_analysis:
    rust_code_mcp_find_definition:
      tool_name: find_definition
      description: "Find where a Rust symbol (function, struct, trait, etc.) is defined"
      location: "src/tools/search_tool.rs:537-609"
      input_parameters:
        symbol_name:
          type: String
          required: true
          description: "Symbol name to find the definition for"
        directory:
          type: String
          required: true
          description: "Directory to search in"
      output_format:
        type: "CallToolResult with Content::text"
        structure: |
          Found {count} definition(s) for '{symbol}':
          - {file_path}:{line_number} ({symbol_kind})
      implementation_details:
        parser: "RustParser with tree-sitter"
        recursion: "Recursively searches .rs files"
        symbol_kinds: "function, struct, trait, enum, impl, module"

    rust_code_mcp_find_references:
      tool_name: find_references
      description: "Find all places where a symbol is referenced or called"
      location: "src/tools/search_tool.rs:612-770"
      input_parameters:
        symbol_name:
          type: String
          required: true
          description: "Symbol name to find references to"
        directory:
          type: String
          required: true
          description: "Directory to search in"
      output_format:
        type: "CallToolResult with Content::text"
        structure: |
          Found {total} reference(s) to '{symbol}' in {files} file(s):
          
          Function Calls ({count} references):
          - {file} (called by: {callers})
          
          Type Usage ({count} references):
          - {file} ({usage_contexts})
      implementation_details:
        reference_types:
          - "Function calls (via call graph)"
          - "Type usage (parameters, returns, fields, impl blocks, let bindings, generics)"
        usage_contexts:
          - "parameter in {function}"
          - "return type of {function}"
          - "field '{name}' in struct {struct}"
          - "impl {trait} for type"
          - "let binding"
          - "generic type argument"

    rust_code_mcp_get_dependencies:
      tool_name: get_dependencies
      description: "Get import dependencies for a Rust source file"
      location: "src/tools/search_tool.rs:773-814"
      input_parameters:
        file_path:
          type: String
          required: true
          description: "Path to the file to analyze"
      output_format:
        type: "CallToolResult with Content::text"
        structure: |
          Dependencies for '{file}':
          
          Imports ({count}):
          - {import_path}
      implementation_details:
        parser: "RustParser with tree-sitter"
        import_types: "use statements, extern crate"

    rust_code_mcp_get_call_graph:
      tool_name: get_call_graph
      description: "Get the call graph showing function call relationships"
      location: "src/tools/search_tool.rs:817-896"
      input_parameters:
        file_path:
          type: String
          required: true
          description: "Path to the file to analyze"
        symbol_name:
          type: "Option<String>"
          required: false
          description: "Optional: specific symbol to get call graph for"
      output_format:
        type: "CallToolResult with Content::text"
        structure_with_symbol: |
          Call graph for '{file}':
          
          Symbol: {name}
          
          Calls ({count}):
            ‚Üí {callee}
          
          Called by ({count}):
            ‚Üê {caller}
        structure_whole_file: |
          Call graph for '{file}':
          
          Functions: {count}
          Call relationships: {count}
          
          Call relationships:
          {function} ‚Üí [{callees}]
      implementation_details:
        graph_structure: "Directed graph of function calls"
        bidirectional: "Shows both callers and callees"

    rust_code_mcp_analyze_complexity:
      tool_name: analyze_complexity
      description: "Analyze code complexity metrics (LOC, cyclomatic complexity, function count)"
      location: "src/tools/search_tool.rs:899-1003"
      input_parameters:
        file_path:
          type: String
          required: true
          description: "Path to the file to analyze"
      output_format:
        type: "CallToolResult with Content::text"
        structure: |
          Complexity analysis for '{file}':
          
          === Code Metrics ===
          Total lines:           {count}
          Non-empty lines:       {count}
          Comment lines:         {count}
          Code lines (approx):   {count}
          
          === Symbol Counts ===
          Functions:             {count}
          Structs:               {count}
          Traits:                {count}
          
          === Complexity ===
          Total cyclomatic:      {count}
          Avg per function:      {float}
          Function calls:        {count}
      implementation_details:
        metrics:
          - "Lines of code (total, non-empty, comments, code-only)"
          - "Symbol counts (functions, structs, traits)"
          - "Cyclomatic complexity (decision points: if, else if, while, for, match, &&, ||)"
          - "Average complexity per function"
          - "Function call count from call graph"

    rust_code_mcp_get_similar_code:
      tool_name: get_similar_code
      description: "Find code snippets semantically similar to a query using embeddings"
      location: "src/tools/search_tool.rs:1006-1095"
      input_parameters:
        query:
          type: String
          required: true
          description: "Code snippet or query to find similar code"
        directory:
          type: String
          required: true
          description: "Directory containing the codebase"
        limit:
          type: "Option<usize>"
          required: false
          default: 5
          description: "Number of similar results to return"
      output_format:
        type: "CallToolResult with Content::text"
        structure: |
          Found {count} similar code snippet(s) for query '{query}':
          
          1. Score: {score} | File: {path} | Symbol: {name} ({kind})
             Lines: {start}-{end}
             Doc: {docstring}
             Code preview:
             {first_3_lines}
      implementation_details:
        embedding_model: "all-MiniLM-L6-v2 (384 dimensions)"
        vector_db: "Qdrant (embedded or remote)"
        similarity_metric: "Cosine similarity"
        search_mode: "Vector-only (no BM25 fusion for this tool)"

    claude_context_equivalent:
      status: "No direct equivalents"
      notes: |
        claude-context does not provide:
        - Symbol definition lookup
        - Reference finding
        - Dependency analysis
        - Call graph visualization
        - Complexity metrics
        - Dedicated semantic search tool
        
        These capabilities would require:
        - Implementing tree-sitter parsing
        - Building call graph infrastructure
        - Adding code metrics calculation
        - Creating specialized MCP tool handlers

# ==============================================================================
# OVERLAPPING CAPABILITIES
# ==============================================================================

overlapping_capabilities:
  
  search_functionality:
    capability: "Full-text keyword search in codebase"
    rust_code_mcp:
      tool: search
      method: "BM25 via Tantivy"
      features:
        - "On-demand indexing with incremental updates"
        - "Persistent index"
        - "SHA-256 change detection"
        - "Binary file filtering"
    claude_context:
      tool: search_code
      method: "Hybrid (BM25 + dense vector)"
      features:
        - "Natural language queries"
        - "Background indexing"
        - "Merkle DAG change detection"
        - "Extension filtering"
    comparison:
      similarity: "Both use BM25 for lexical search"
      differences:
        - "rust-code-mcp: keyword-based, immediate results"
        - "claude-context: NLP queries, requires pre-indexing"

  semantic_search:
    capability: "Vector-based semantic code search"
    rust_code_mcp:
      tool: get_similar_code
      method: "Local embeddings (fastembed) + Qdrant"
      model: "all-MiniLM-L6-v2 (384d)"
      cost: "Free (local)"
    claude_context:
      tool: search_code
      method: "API embeddings + Milvus/Zilliz"
      model: "text-embedding-3-large (3072d) or voyage-code-3"
      cost: "API fees ($$)"
    comparison:
      similarity: "Both support semantic/vector search"
      differences:
        - "rust-code-mcp: 100% local, lower dimensions"
        - "claude-context: cloud-based, higher quality embeddings"

  hybrid_search:
    capability: "Combined BM25 + vector search"
    rust_code_mcp:
      implementation: "HybridSearch with RRF (Reciprocal Rank Fusion)"
      location: "src/search/mod.rs"
      fusion_algorithm: "Reciprocal Rank Fusion"
      components:
        - "Bm25Search (Tantivy on chunks)"
        - "VectorSearch (Qdrant wrapper)"
    claude_context:
      implementation: "Hybrid retrieval in search_code"
      fusion_algorithm: "Proprietary (not documented)"
      components:
        - "BM25 component"
        - "Dense vector component"
    comparison:
      similarity: "Both implement hybrid search"
      differences:
        - "rust-code-mcp: Explicit RRF with configurable weights"
        - "claude-context: Integrated in search_code tool"

  incremental_indexing:
    capability: "Only reindex changed files"
    rust_code_mcp:
      method: "SHA-256 per-file hashing"
      storage: "sled KV store for metadata"
      performance: "Seconds (must hash every file)"
      granularity: "File-level"
    claude_context:
      method: "Merkle DAG (tree-based hashing)"
      storage: "~/.context/merkle/ snapshots"
      performance: "Milliseconds (root hash comparison)"
      granularity: "Directory-level + file-level"
    comparison:
      similarity: "Both support incremental updates"
      differences:
        - "claude-context: 100-1000x faster change detection"
        - "claude-context: Hierarchical directory skipping"

  state_persistence:
    capability: "Index survives restarts"
    rust_code_mcp:
      storage:
        - "Tantivy index: ~/.local/share/rust-code-mcp/search/index/"
        - "Metadata cache: ~/.local/share/rust-code-mcp/search/cache/"
        - "Qdrant: storage/ directory"
    claude_context:
      storage:
        - "Merkle snapshots: ~/.context/merkle/"
        - "Global config: ~/.context/.env"
        - "Milvus/Zilliz: cloud-hosted"
    comparison:
      similarity: "Both persist state locally"
      differences:
        - "rust-code-mcp: Fully local storage"
        - "claude-context: Hybrid (local snapshots + cloud vectors)"

  code_parsing:
    capability: "AST-based code understanding"
    rust_code_mcp:
      parser: "tree-sitter with tree-sitter-rust"
      location: "src/parser/mod.rs"
      features:
        - "Symbol extraction (functions, structs, traits, impls)"
        - "Call graph building"
        - "Import tracking"
        - "Type reference tracking"
        - "Docstring extraction"
    claude_context:
      parser: "tree-sitter (AST mode)"
      features:
        - "Function/class/method boundary detection"
        - "Fallback to character-based splitting"
      limitations: "No call graph or symbol analysis exposed"
    comparison:
      similarity: "Both use tree-sitter for parsing"
      differences:
        - "rust-code-mcp: Deep AST analysis with multiple features"
        - "claude-context: Parsing for chunking only"

# ==============================================================================
# UNIQUE CAPABILITIES
# ==============================================================================

unique_capabilities:

  rust_code_mcp_unique:
    
    symbol_definition_lookup:
      tool: find_definition
      capability: "Locate where symbols are defined"
      use_cases:
        - "Find struct definition"
        - "Find function implementation"
        - "Navigate to trait definition"
      implementation: "Tree-sitter symbol extraction"
      equivalent_in_claude_context: "None"
    
    reference_finding:
      tool: find_references
      capability: "Find all usages of a symbol"
      use_cases:
        - "Find all callers of a function"
        - "Find all places a type is used"
        - "Understand function/type usage patterns"
      implementation: "Call graph + type reference tracking"
      equivalent_in_claude_context: "None"
    
    dependency_analysis:
      tool: get_dependencies
      capability: "List all imports for a file"
      use_cases:
        - "Understand file dependencies"
        - "Analyze import structure"
        - "Detect unused imports (potential)"
      implementation: "Import statement extraction"
      equivalent_in_claude_context: "None"
    
    call_graph_visualization:
      tool: get_call_graph
      capability: "Show function call relationships"
      use_cases:
        - "Understand control flow"
        - "Find call chains"
        - "Identify dead code"
      implementation: "Directed graph of function calls"
      equivalent_in_claude_context: "None"
    
    complexity_metrics:
      tool: analyze_complexity
      capability: "Calculate code quality metrics"
      use_cases:
        - "Measure cyclomatic complexity"
        - "Count LOC and symbols"
        - "Identify refactoring targets"
      implementation: "AST analysis + keyword counting"
      equivalent_in_claude_context: "None"
    
    raw_file_reading:
      tool: read_file_content
      capability: "Read any file directly"
      use_cases:
        - "View source code"
        - "Read configuration files"
        - "Access documentation"
      implementation: "Direct filesystem read with binary detection"
      equivalent_in_claude_context: "None"
    
    local_privacy:
      capability: "100% local operation"
      features:
        - "No API calls required"
        - "No code sent to external services"
        - "Works offline"
        - "Zero recurring costs"
      implementation:
        - "Local embeddings (fastembed)"
        - "Local vector DB (Qdrant embedded)"
        - "Local search index (Tantivy)"
    
    dedicated_lexical_index:
      capability: "Full-featured BM25 index"
      features:
        - "File-level indexing in Tantivy"
        - "Chunk-level indexing via Bm25Search"
        - "Persistent index"
        - "Fast keyword search"
      implementation: "Tantivy full-text search engine"
  
  claude_context_unique:
    
    async_background_indexing:
      tool: index_codebase
      capability: "Non-blocking indexing with progress tracking"
      features:
        - "Returns immediately"
        - "Indexing runs in background"
        - "Progress monitoring via get_indexing_status"
      use_cases:
        - "Index large codebases without blocking"
        - "Monitor indexing progress"
        - "Retry failed indexing"
      equivalent_in_rust_code_mcp: "None (indexing is synchronous in search tool)"
    
    indexing_status_monitoring:
      tool: get_indexing_status
      capability: "Check current indexing state"
      features:
        - "Progress percentage"
        - "Indexed file count"
        - "Total chunk count"
        - "Last indexed timestamp"
        - "Error reporting"
      use_cases:
        - "Monitor background indexing"
        - "Verify indexing completion"
        - "Debug indexing failures"
      equivalent_in_rust_code_mcp: "None"
    
    explicit_index_management:
      tool: clear_index
      capability: "Delete indexed codebase"
      features:
        - "Clear index for specific path"
        - "Show remaining codebases"
        - "Free up storage"
      use_cases:
        - "Remove stale indexes"
        - "Free disk space"
        - "Reset corrupted index"
      equivalent_in_rust_code_mcp: "None (no index management tool)"
    
    merkle_dag_change_detection:
      capability: "Millisecond-level change detection"
      features:
        - "Hierarchical directory hashing"
        - "Root hash comparison (phase 1)"
        - "Selective tree traversal (phase 2)"
        - "60-80% skip rate on typical git workflows"
      performance: "<10ms for unchanged projects"
      equivalent_in_rust_code_mcp: "SHA-256 per-file (seconds, not milliseconds)"
    
    natural_language_queries:
      tool: search_code
      capability: "NLP-based semantic search"
      features:
        - "Natural language query understanding"
        - "Semantic similarity ranking"
        - "High-dimensional embeddings (3072d)"
      use_cases:
        - "Find functions that handle authentication"
        - "Locate error handling patterns"
        - "Search for similar algorithms"
      equivalent_in_rust_code_mcp: "get_similar_code (lower quality, 384d)"
    
    configurable_splitter:
      tool: index_codebase (splitter parameter)
      capability: "Choose code chunking strategy"
      options:
        ast: "Tree-sitter syntax-aware splitting"
        langchain: "Character-based splitting (1000 chars, 200 overlap)"
      use_cases:
        - "AST for structured code"
        - "Langchain for mixed/documentation content"
      equivalent_in_rust_code_mcp: "Fixed semantic chunking strategy"
    
    multi_codebase_management:
      capability: "Manage multiple indexed codebases"
      features:
        - "Track multiple project indexes"
        - "List all indexed codebases"
        - "Per-codebase status monitoring"
      implementation: "Global codebase registry"
      equivalent_in_rust_code_mcp: "Single-codebase focus (no multi-project tracking)"
    
    extension_filtering:
      tool: search_code (extensionFilter parameter)
      capability: "Filter search results by file type"
      features:
        - "Search only .ts files"
        - "Exclude test files"
        - "Language-specific searches"
      use_cases:
        - "Find TypeScript implementations only"
        - "Exclude generated code"
      equivalent_in_rust_code_mcp: "None (searches all indexed files)"

# ==============================================================================
# OUTPUT FORMAT COMPARISON
# ==============================================================================

output_format_comparison:

  mcp_protocol:
    rust_code_mcp:
      type: "CallToolResult"
      content_structure: |
        CallToolResult {
          content: Vec<Content>,
          isError: Option<bool>
        }
      content_format: "Content::text(String)"
    claude_context:
      type: "MCP CallToolResult"
      content_structure: |
        {
          content: [{
            type: "text",
            text: string
          }],
          isError?: boolean
        }
      content_format: "Plain text in content[0].text"
    similarity: "Both use MCP CallToolResult with text content"

  text_formatting:
    rust_code_mcp:
      style: "Plain text with minimal formatting"
      examples:
        search: "Hit: {path} (Score: {score})"
        find_definition: "- {path}:{line} ({kind})"
        analyze_complexity: "=== Code Metrics ===\nTotal lines: {count}"
    claude_context:
      style: "Rich markdown with code blocks"
      examples:
        search_code: |
          1. Code snippet (typescript) [project]
             Location: src/auth.ts:23-45
             Rank: 1
             Context:
          ```typescript
          export async function authenticate() { ... }
          ```
    comparison:
      rust_code_mcp: "Simpler, more concise output"
      claude_context: "Richer, more readable with syntax highlighting"

  score_display:
    rust_code_mcp:
      search: "Displays BM25 scores: (Score: 4.28)"
      get_similar_code: "Displays similarity scores: Score: 0.8532"
    claude_context:
      search_code: "No scores displayed, only rank order"
    comparison: "rust-code-mcp shows raw scores, claude-context hides implementation details"

  location_format:
    rust_code_mcp:
      format: "{absolute_path}:{line_number}"
      example: "/home/user/project/src/main.rs:42"
    claude_context:
      format: "{relative_path}:{start_line}-{end_line}"
      example: "src/main.rs:42-67"
    comparison: "claude-context uses relative paths and line ranges"

  error_handling:
    rust_code_mcp:
      method: "McpError::invalid_params() with descriptive messages"
      examples:
        - "The specified path '{path}' does not exist"
        - "Search keyword is empty. Please enter a valid keyword."
    claude_context:
      method: "isError: true with formatted error messages"
      examples:
        - "‚ùå Not indexed. Use index_codebase tool to index this codebase first."
        - "‚ùå Indexing failed\n\nError: {message}"
    comparison: "claude-context uses emoji indicators, rust-code-mcp uses plain text"

# ==============================================================================
# PARAMETER VALIDATION COMPARISON
# ==============================================================================

parameter_validation:

  path_handling:
    rust_code_mcp:
      acceptance: "Relative or absolute paths"
      validation:
        - "Path::new(&input)"
        - "path.is_dir() / path.is_file()"
        - "path.exists()"
      errors:
        - "The specified path '{path}' is not a directory"
        - "File '{path}' does not exist"
    claude_context:
      acceptance: "ONLY absolute paths"
      validation:
        - "Must be absolute path"
        - "Path existence check"
      errors:
        - "Path must be absolute"
      notes: "Explicitly requires absolute paths to avoid ambiguity"
    recommendation: "rust-code-mcp should adopt absolute-only policy"

  empty_input_handling:
    rust_code_mcp:
      keyword_validation: "if keyword.trim().is_empty() { error }"
      symbol_validation: "No explicit empty check (relies on parser)"
    claude_context:
      query_validation: "Validated before API call"
      path_validation: "Required field validation"

  limits_and_bounds:
    rust_code_mcp:
      search_limit: "Hardcoded TopDocs::with_limit(10)"
      similar_code_limit: "limit.unwrap_or(5), no maximum"
    claude_context:
      search_limit: "Default 10, maximum 50, user-configurable"
    recommendation: "rust-code-mcp should add configurable limits with maximums"

# ==============================================================================
# ARCHITECTURAL DIFFERENCES
# ==============================================================================

architectural_differences:

  language_and_runtime:
    rust_code_mcp:
      language: "Rust"
      runtime: "Native compiled binary"
      async_model: "Tokio async runtime"
    claude_context:
      language: "TypeScript"
      runtime: "Node.js"
      async_model: "JavaScript async/await"

  embedding_generation:
    rust_code_mcp:
      method: "Local inference"
      library: "fastembed-rs"
      model: "all-MiniLM-L6-v2 (384 dimensions)"
      cost: "$0 (local CPU/GPU)"
      privacy: "100% private"
      performance: "Slower inference, no network latency"
    claude_context:
      method: "API calls"
      providers: "OpenAI, VoyageAI, Ollama, Gemini"
      model: "text-embedding-3-large (3072d) or voyage-code-3"
      cost: "$0.00013 per 1K tokens (OpenAI)"
      privacy: "Code sent to external API"
      performance: "Fast API, network latency"
    trade_offs:
      rust_code_mcp: "Privacy + cost vs quality"
      claude_context: "Quality + speed vs privacy + cost"

  vector_database:
    rust_code_mcp:
      database: "Qdrant"
      deployment: "Embedded (in-process) or remote"
      storage: "./storage/ directory"
      connection: "Local gRPC or HTTP"
    claude_context:
      database: "Milvus / Zilliz Cloud"
      deployment: "Remote (managed service)"
      storage: "Cloud-hosted"
      connection: "Network API"
    trade_offs:
      rust_code_mcp: "Self-hosted, no dependencies"
      claude_context: "Managed service, requires account"

  lexical_search_index:
    rust_code_mcp:
      engine: "Tantivy"
      indexing:
        - "File-level: FileSchema (5 fields)"
        - "Chunk-level: ChunkSchema via Bm25Search"
      storage: "~/.local/share/rust-code-mcp/search/index/"
      features: "Full-featured search engine"
    claude_context:
      engine: "BM25 component (implementation not documented)"
      indexing: "Integrated with hybrid search"
      storage: "Part of Milvus/Zilliz"
      features: "BM25 scoring only"

  change_detection:
    rust_code_mcp:
      algorithm: "SHA-256 per-file hashing"
      implementation: "src/metadata_cache/mod.rs"
      storage: "sled KV store"
      process:
        - "Read file content"
        - "Compute SHA-256 hash"
        - "Compare with cached hash"
        - "Reindex if different"
      performance: "O(n) where n = number of files (seconds)"
      granularity: "File-level only"
    claude_context:
      algorithm: "Merkle DAG (tree-based hashing)"
      implementation: "Proprietary (not open in public repo)"
      storage: "~/.context/merkle/ snapshots"
      process:
        - "Phase 1: Compare root hash (milliseconds)"
        - "Phase 2: Traverse changed subtrees (seconds)"
        - "Phase 3: Reindex changed files (variable)"
      performance: "O(log n) for detection, O(m) for reindex where m = changed files"
      granularity: "Directory-level + file-level"
    impact:
      rust_code_mcp: "Must hash every file on every search"
      claude_context: "Skip entire directories if unchanged (60-80% skip rate)"

  indexing_workflow:
    rust_code_mcp:
      trigger: "On-demand during search tool call"
      behavior: "Synchronous (blocks until complete)"
      feedback: "Logs during indexing, final result after commit"
      monitoring: "No dedicated status tool"
    claude_context:
      trigger: "Explicit index_codebase tool call"
      behavior: "Asynchronous (background worker)"
      feedback: "Immediate acknowledgment, status via get_indexing_status"
      monitoring: "Dedicated status tool with progress percentage"
    user_experience:
      rust_code_mcp: "First search is slow, subsequent searches fast"
      claude_context: "Index first, then all searches are fast"

  code_chunking:
    rust_code_mcp:
      strategy: "Symbol-based semantic chunking"
      implementation: "src/chunking/mod.rs"
      method:
        - "Extract symbols via tree-sitter"
        - "Create chunks per symbol (function, struct, impl)"
        - "Enrich with context (imports, calls, docstrings)"
        - "Add overlap for continuity"
      format: "Contextual retrieval pattern"
    claude_context:
      strategy: "Configurable (AST or character-based)"
      implementation: "@zilliz/claude-context-core/splitter"
      methods:
        ast:
          - "tree-sitter boundary detection"
          - "Function/class/method splits"
          - "Automatic fallback to langchain"
        langchain:
          - "RecursiveCharacterTextSplitter"
          - "1000 chars per chunk"
          - "200 char overlap"

  multi_language_support:
    rust_code_mcp:
      languages: "Rust only (tree-sitter-rust)"
      extensibility: "Would require adding tree-sitter-{lang} grammars"
      parsing: "Deep AST analysis for Rust"
    claude_context:
      languages: ".ts, .tsx, .js, .jsx, .py, .java, .cpp, .c, .h, .hpp, .cs, .go, .rs, .php, .rb, .swift, .kt, .scala, .m, .mm, .md"
      extensibility: "customExtensions parameter"
      parsing: "Shallow parsing for chunking"

# ==============================================================================
# PERFORMANCE CHARACTERISTICS
# ==============================================================================

performance_characteristics:

  cold_start:
    rust_code_mcp:
      first_search: "50-100ms (2 files)"
      components:
        - "Index creation: ~30ms"
        - "File scanning: ~20ms"
        - "Tantivy indexing: ~30ms"
        - "Search query: <10ms"
    claude_context:
      first_index: "Seconds to minutes (depends on codebase size)"
      components:
        - "File scanning: seconds"
        - "Merkle tree building: milliseconds"
        - "Embedding generation: API latency"
        - "Vector insertion: network latency"

  warm_start:
    rust_code_mcp:
      unchanged_files: "<10ms (skipped via SHA-256)"
      changed_files: "15-20ms (selective reindexing)"
    claude_context:
      unchanged_project: "<10ms (Merkle root match)"
      changed_files: "Milliseconds (Merkle subtree traversal)"

  search_latency:
    rust_code_mcp:
      search_tool: "<100ms (BM25 only)"
      get_similar_code: "200-1000ms (embedding + vector search)"
    claude_context:
      search_code: "200-1000ms (hybrid BM25 + vector)"

  token_efficiency:
    claude_context:
      claim: "40% token reduction vs grep-only approaches"
      source: "https://zilliz.com/blog/why-im-against-claude-codes-grep-only-retrieval-it-just-burns-too-many-tokens"
    rust_code_mcp:
      measurement: "Not benchmarked"

# ==============================================================================
# DEPLOYMENT AND CONFIGURATION
# ==============================================================================

deployment:

  installation:
    rust_code_mcp:
      method: "Build from source"
      commands:
        - "cargo build --release"
        - "Binary: ./target/release/file-search-mcp"
      dependencies: "Rust toolchain only"
    claude_context:
      method: "npm package"
      commands:
        - "npm install -g @zilliz/claude-context-mcp"
        - "npx @zilliz/claude-context-mcp"
      dependencies: "Node.js runtime"

  configuration:
    rust_code_mcp:
      method: "Environment variables"
      variables:
        - "RUST_LOG=info|debug"
        - "QDRANT_MODE=embedded|remote"
        - "QDRANT_URL=http://localhost:6333"
      files: "None (no config file)"
    claude_context:
      method: "Environment variables + config file"
      variables:
        - "OPENAI_API_KEY"
        - "MILVUS_ADDRESS"
        - "MILVUS_TOKEN"
        - "CUSTOM_EXTENSIONS"
        - "CUSTOM_IGNORE_PATTERNS"
      files: "~/.context/.env (global config)"

  mcp_client_setup:
    rust_code_mcp:
      config: |
        {
          "mcpServers": {
            "rust-code-mcp": {
              "command": "/path/to/file-search-mcp",
              "env": {
                "RUST_LOG": "info"
              }
            }
          }
        }
    claude_context:
      config: |
        {
          "mcpServers": {
            "claude-context": {
              "command": "npx",
              "args": ["-y", "@zilliz/claude-context-mcp"],
              "env": {
                "OPENAI_API_KEY": "sk-...",
                "MILVUS_ADDRESS": "https://...",
                "MILVUS_TOKEN": "..."
              }
            }
          }
        }

  external_dependencies:
    rust_code_mcp:
      required: "None"
      optional:
        - "Qdrant server (if using remote mode)"
    claude_context:
      required:
        - "OpenAI/Voyage/Ollama API account"
        - "Milvus or Zilliz Cloud account"
      optional: "None"

# ==============================================================================
# USE CASE SUITABILITY
# ==============================================================================

use_case_suitability:

  best_for_rust_code_mcp:
    - use_case: "Privacy-sensitive codebases"
      reason: "100% local, no external API calls"
    - use_case: "Air-gapped/offline environments"
      reason: "No network dependencies"
    - use_case: "Zero-cost operation"
      reason: "No API fees, no cloud services"
    - use_case: "Deep Rust code analysis"
      reason: "Specialized tools for Rust symbols, call graphs, complexity"
    - use_case: "Rapid prototyping"
      reason: "On-demand indexing, immediate results"
    - use_case: "Code navigation and refactoring"
      reason: "find_definition, find_references, get_call_graph"

  best_for_claude_context:
    - use_case: "Large-scale production codebases"
      reason: "Optimized change detection, proven 40% token reduction"
    - use_case: "Multi-language projects"
      reason: "Supports 20+ languages out of box"
    - use_case: "Natural language code search"
      reason: "High-quality embeddings (3072d), semantic understanding"
    - use_case: "Team environments"
      reason: "Centralized Zilliz Cloud storage, shared indexes"
    - use_case: "When API costs are acceptable"
      reason: "Superior embedding quality justifies cost"
    - use_case: "Projects requiring fast change detection"
      reason: "Merkle DAG enables millisecond detection on huge codebases"

# ==============================================================================
# MATURITY AND PRODUCTION READINESS
# ==============================================================================

maturity:

  rust_code_mcp:
    status: "Phase 7 Complete - Testing Phase"
    strengths:
      - "8 specialized tools implemented"
      - "Comprehensive testing (45 passing tests)"
      - "Integration verified with Claude Code"
    limitations:
      - "Rust-only language support"
      - "SHA-256 change detection (slow for large projects)"
      - "Synchronous indexing (blocks on first search)"
      - "No index management tools"
    roadmap:
      - "Phase 8: Optimization & release"
      - "Merkle tree change detection (recommended)"
      - "Async indexing workflow"
      - "Multi-language support"

  claude_context:
    status: "Production - Deployed across organizations"
    strengths:
      - "Proven token reduction (40%)"
      - "Multi-language support (20+ languages)"
      - "Millisecond change detection (Merkle DAG)"
      - "Async background indexing"
      - "Professional documentation"
    limitations:
      - "Requires external services (OpenAI, Zilliz)"
      - "Recurring API costs"
      - "Code sent to external APIs (privacy concern)"
      - "No deep code analysis tools (call graphs, complexity)"
    roadmap: "Stable, ongoing maintenance"

# ==============================================================================
# KEY INSIGHTS AND RECOMMENDATIONS
# ==============================================================================

key_insights:

  merkle_dag_validation:
    finding: "claude-context validates that Merkle tree change detection is essential, not optional"
    evidence:
      - "Millisecond root hash comparison vs seconds for SHA-256"
      - "Hierarchical directory-level skipping (60-80% skip rate)"
      - "Proven at production scale"
    recommendation: "rust-code-mcp should prioritize Merkle DAG implementation in Phase 8"

  async_indexing_workflow:
    finding: "Background indexing with status monitoring is superior UX"
    evidence:
      - "index_codebase returns immediately"
      - "get_indexing_status provides progress feedback"
      - "Users aren't blocked during initial indexing"
    recommendation: "rust-code-mcp should decouple indexing from search, add status tool"

  tool_count_vs_depth:
    finding: "More tools doesn't mean better, but rust-code-mcp's extra tools provide unique value"
    analysis:
      claude_context: "4 focused tools for search workflow"
      rust_code_mcp: "8 tools covering search + code analysis"
      overlap: "2 tools (search/similar)"
      unique_to_rust: "6 tools (read, find_definition, find_references, dependencies, call_graph, complexity)"
    recommendation: "rust-code-mcp should emphasize code analysis capabilities as differentiator"

  local_vs_cloud:
    finding: "Local-first is a competitive advantage, not a limitation"
    rust_code_mcp_advantages:
      - "Zero cost"
      - "Privacy guarantee"
      - "Offline capability"
      - "No vendor lock-in"
    trade_off: "Lower embedding quality (384d vs 3072d)"
    recommendation: "Market rust-code-mcp as 'privacy-first alternative to claude-context'"

  absolute_path_requirement:
    finding: "claude-context's absolute-only path policy prevents ambiguity"
    rust_code_mcp_current: "Accepts relative or absolute paths"
    risk: "Different working directories can cause confusion"
    recommendation: "rust-code-mcp should require absolute paths in all tools"

  markdown_output_formatting:
    finding: "claude-context's markdown output is more readable for LLMs"
    evidence:
      - "Code blocks with syntax highlighting"
      - "Structured sections"
      - "Emoji indicators (‚úÖ ‚ùå üîÑ)"
    recommendation: "rust-code-mcp should adopt markdown formatting for consistency"

# ==============================================================================
# SUMMARY COMPARISON TABLE
# ==============================================================================

summary_table:
  feature: [
    "Tool Count",
    "Search Tools",
    "Code Analysis Tools",
    "File Operations",
    "Index Management",
    "Indexing Strategy",
    "Change Detection",
    "Embedding Generation",
    "Vector Database",
    "Lexical Search",
    "Hybrid Search",
    "Privacy",
    "Cost",
    "Multi-Language",
    "Production Ready",
  ]
  
  rust_code_mcp: [
    "8 tools",
    "2 (search, get_similar_code)",
    "5 (find_definition, find_references, get_dependencies, get_call_graph, analyze_complexity)",
    "1 (read_file_content)",
    "0 (none)",
    "On-demand, synchronous",
    "SHA-256 per-file (seconds)",
    "Local (fastembed, 384d)",
    "Qdrant (embedded/remote)",
    "Tantivy (full-featured)",
    "Yes (RRF)",
    "100% local",
    "$0",
    "Rust only",
    "Phase 7 - Testing",
  ]
  
  claude_context: [
    "4 tools",
    "2 (index_codebase, search_code)",
    "0 (none)",
    "0 (none)",
    "2 (clear_index, get_indexing_status)",
    "Background, asynchronous",
    "Merkle DAG (milliseconds)",
    "API (OpenAI, 3072d)",
    "Milvus/Zilliz Cloud",
    "BM25 component",
    "Yes (proprietary)",
    "Code sent to APIs",
    "$$$ (API fees)",
    "20+ languages",
    "Production",
  ]

# ==============================================================================
# FINAL RECOMMENDATIONS FOR RUST-CODE-MCP
# ==============================================================================

recommendations_for_rust_code_mcp:

  priority_1_critical:
    - action: "Implement Merkle DAG change detection"
      rationale: "claude-context proves this is 100-1000x faster than SHA-256"
      implementation: "Add rs_merkle dependency, build tree on index, cache snapshots"
      impact: "Massive performance improvement on large codebases"
    
    - action: "Decouple indexing from search (async workflow)"
      rationale: "Blocking on first search is poor UX"
      implementation: "Create index_codebase tool, move indexing to background, add get_indexing_status"
      impact: "Better user experience, matches claude-context workflow"

  priority_2_high:
    - action: "Add clear_index tool"
      rationale: "Users need index management capability"
      implementation: "Clear Tantivy index, Qdrant collection, and Merkle snapshot for a path"
      impact: "Complete index lifecycle management"
    
    - action: "Require absolute paths in all tools"
      rationale: "Prevents ambiguity, matches claude-context best practice"
      implementation: "Add validation: if !path.is_absolute() { error }"
      impact: "More reliable, consistent behavior"
    
    - action: "Adopt markdown output formatting"
      rationale: "Better readability for LLMs and users"
      implementation: "Format results with code blocks, sections, emoji indicators"
      impact: "Improved presentation, consistency with other MCP servers"

  priority_3_medium:
    - action: "Add configurable result limits with maximums"
      rationale: "Prevent excessive results, match claude-context"
      implementation: "Add limit parameters with .min(50) capping"
      impact: "Better performance, consistent API"
    
    - action: "Implement relative path display"
      rationale: "Shorter, more readable than absolute paths"
      implementation: "Store base directory, display relative paths in results"
      impact: "Cleaner output"
    
    - action: "Add line range support (start-end)"
      rationale: "More context than single line number"
      implementation: "Extend SymbolRange to include both start and end lines"
      impact: "Better location information"

  priority_4_future:
    - action: "Multi-language support"
      rationale: "Expand beyond Rust-only"
      implementation: "Add tree-sitter-{javascript,python,go} grammars"
      impact: "Broader applicability"
    
    - action: "Configurable chunking strategies"
      rationale: "Match claude-context flexibility"
      implementation: "Add splitter parameter (ast | text)"
      impact: "Better handling of different content types"

  strategic_positioning:
    tagline: "Privacy-First Code Intelligence for Rust"
    differentiators:
      - "100% local operation (no API calls)"
      - "Deep code analysis (call graphs, complexity, references)"
      - "Zero cost (no subscriptions, no API fees)"
      - "Rust-specific optimization"
    target_users:
      - "Privacy-conscious developers"
      - "Open-source projects"
      - "Air-gapped environments"
      - "Cost-sensitive individuals/teams"
      - "Rust developers needing deep analysis"

# ==============================================================================
# METADATA
# ==============================================================================

metadata:
  analysis_date: "2025-10-19"
  rust_code_mcp_commit: "d567edd (Phase 7 Complete)"
  claude_context_version: "@zilliz/claude-context-mcp@latest"
  sources:
    - "https://github.com/zilliztech/claude-context"
    - "https://www.npmjs.com/package/@zilliz/claude-context-mcp"
    - "/home/molaco/Documents/rust-code-mcp/src/tools/search_tool.rs"
    - "/home/molaco/Documents/rust-code-mcp/TESTING.md"
    - "https://zilliz.com/blog/why-im-against-claude-codes-grep-only-retrieval-it-just-burns-too-many-tokens"
  analysis_method: "Direct source code examination + official documentation"
  confidence: "High (based on source code and production documentation)"