mcp_server_implementation_comparison:
  metadata:
    analysis_date: "2025-10-22"
    systems_compared:
      - name: "rust-code-mcp"
        sdk: "rmcp (Rust SDK)"
        language: "Rust"
        repo: "local"
      - name: "claude-context"
        sdk: "@modelcontextprotocol/sdk"
        language: "TypeScript"
        repo: "github.com/zilliztech/claude-context"
    focus_areas:
      - MCP tool definitions
      - Request/response handling
      - stdio transport
      - Tool registration patterns
      - Server initialization
      - Error handling

  # ============================================================================
  # 1. MCP SERVER INITIALIZATION
  # ============================================================================
  
  server_initialization:
    
    rust_code_mcp:
      entry_point: "src/main.rs:7-39"
      framework: "rmcp (Rust SDK for Model Context Protocol)"
      runtime: "tokio async"
      
      initialization_flow:
        step_1_logging:
          code: |
            tracing_subscriber::fmt()
                .with_env_filter(EnvFilter::from_default_env()
                    .add_directive(tracing::Level::DEBUG.into()))
                .with_writer(std::io::stderr)
                .with_ansi(false)
                .init();
          description: "Configure structured logging to stderr"
          note: "ANSI disabled for clean stdio transport"
        
        step_2_background_services:
          code: |
            let sync_manager = Arc::new(SyncManager::with_defaults(300));
            let sync_manager_clone = Arc::clone(&sync_manager);
            tokio::spawn(async move {
                sync_manager_clone.run().await;
            });
          description: "Spawn background sync task for automatic reindexing"
          features:
            - "5-minute interval background sync"
            - "Arc-wrapped for shared ownership"
            - "Tokio spawn for concurrent execution"
        
        step_3_mcp_server:
          code: |
            let service = SearchTool::with_sync_manager(Arc::clone(&sync_manager))
                .serve(stdio())
                .await?;
            service.waiting().await?;
          description: "Start MCP server with stdio transport"
          transport: "stdio()"
          blocking: "Waits for termination signal"
      
      dependencies:
        crate_definition: "Cargo.toml:8-11"
        rmcp_features:
          - "server"
          - "transport-io"
        version: "git main branch"
      
      architecture_pattern: "Unified tool struct with dependency injection"
    
    claude_context:
      entry_point: "Likely src/server.ts or similar (inferred)"
      framework: "@modelcontextprotocol/sdk"
      runtime: "Node.js async"
      
      initialization_flow:
        step_1_server_creation:
          description: "Create MCP server instance"
          pattern: |
            import { Server } from '@modelcontextprotocol/sdk/server/index.js';
            const server = new Server({
              name: 'claude-context',
              version: '1.0.0'
            });
        
        step_2_tool_registration:
          description: "Register tool handlers via server.setRequestHandler"
          pattern: |
            server.setRequestHandler(ListToolsRequestSchema, async () => ({
              tools: [...]
            }));
            
            server.setRequestHandler(CallToolRequestSchema, async (request) => {
              // Handle tool calls
            });
        
        step_3_transport:
          description: "Connect to stdio transport"
          pattern: |
            const transport = new StdioServerTransport();
            await server.connect(transport);
      
      architecture_pattern: "Centralized server with handler registration"
      
      differences_from_rust:
        - "Manual tool registration vs macro-generated routing"
        - "Centralized request handler vs distributed tool methods"
        - "No explicit background service management in server init"

  # ============================================================================
  # 2. TOOL DEFINITION PATTERNS
  # ============================================================================
  
  tool_definitions:
    
    rust_code_mcp:
      framework: "rmcp with procedural macros"
      location: "src/tools/search_tool.rs"
      
      macro_system:
        tool_router_macro:
          location: "src/tools/search_tool.rs:156"
          usage: "#[tool_router]"
          purpose: "Generate routing logic for all #[tool] methods"
          benefits:
            - "Automatic JSON schema generation via schemars"
            - "Type-safe parameter extraction"
            - "Compile-time tool registration"
        
        tool_macro:
          location: "src/tools/search_tool.rs:159, 236, etc."
          usage: '#[tool(description = "...")]'
          purpose: "Mark async method as MCP tool"
          
        tool_handler_macro:
          location: "src/tools/search_tool.rs:983"
          usage: "#[tool_handler]"
          purpose: "Implement ServerHandler trait with tool routing"
      
      tool_struct:
        definition: |
          #[derive(Clone)]
          pub struct SearchTool {
              tool_router: ToolRouter<Self>,
              sync_manager: Option<std::sync::Arc<crate::mcp::SyncManager>>,
          }
        
        constructors:
          basic: "SearchTool::new()"
          with_deps: "SearchTool::with_sync_manager(Arc<SyncManager>)"
        
        tool_router_generation:
          location: "src/tools/search_tool.rs:105"
          code: "tool_router: Self::tool_router()"
          note: "Self::tool_router() generated by #[tool_router] macro"
      
      parameter_definition:
        pattern: "Separate struct per tool with derive macros"
        example: |
          #[derive(Debug, serde::Deserialize, schemars::JsonSchema)]
          pub struct SearchParams {
              #[schemars(description = "Path to the directory to search")]
              pub directory: String,
              #[schemars(description = "Keyword to search for")]
              pub keyword: String,
          }
        
        features:
          - "Automatic JSON schema via schemars"
          - "Type-safe deserialization via serde"
          - "Field-level documentation in schema"
      
      tool_method_signature:
        pattern: "Async method with Parameters wrapper"
        example: |
          #[tool(description = "Search for keywords in Rust code")]
          async fn search(
              &self,
              Parameters(SearchParams { directory, keyword }): Parameters<SearchParams>,
          ) -> Result<CallToolResult, McpError>
        
        components:
          self_reference: "&self (access to tool state)"
          parameters_wrapper: "Parameters<T> for type-safe extraction"
          destructuring: "Pattern match to extract fields"
          return_type: "Result<CallToolResult, McpError>"
      
      return_values:
        success_pattern: |
          Ok(CallToolResult::success(vec![Content::text(result_str)]))
        
        error_pattern: |
          Err(McpError::invalid_params(
              format!("Error message: {}", e),
              None
          ))
        
        result_types:
          - "CallToolResult::success(Vec<Content>)"
          - "Content::text(String)"
          - "McpError::invalid_params(String, Option<Value>)"
          - "McpError::internal_error(String, Option<Value>)"
      
      server_info:
        location: "src/tools/search_tool.rs:985-1000"
        implementation: |
          fn get_info(&self) -> ServerInfo {
              ServerInfo {
                  protocol_version: ProtocolVersion::V_2024_11_05,
                  capabilities: ServerCapabilities::builder()
                      .enable_prompts()
                      .enable_resources()
                      .enable_tools()
                      .build(),
                  server_info: Implementation::from_build_env(),
                  instructions: Some("This server provides...".into()),
              }
          }
        
        capabilities:
          - "enable_prompts()"
          - "enable_resources()"
          - "enable_tools()"
      
      total_tools: 10
      tool_list:
        - name: "read_file_content"
          location: "search_tool.rs:159-233"
        - name: "search"
          location: "search_tool.rs:236-369"
        - name: "find_definition"
          location: "search_tool.rs:372-444"
        - name: "find_references"
          location: "search_tool.rs:447-613"
        - name: "get_dependencies"
          location: "search_tool.rs:616-657"
        - name: "get_call_graph"
          location: "search_tool.rs:660-739"
        - name: "analyze_complexity"
          location: "search_tool.rs:742-846"
        - name: "health_check"
          location: "search_tool.rs:849-855 (delegates to health_tool.rs)"
        - name: "get_similar_code"
          location: "search_tool.rs:858-971"
        - name: "index_codebase"
          location: "search_tool.rs:974-980 (delegates to index_tool.rs)"
    
    claude_context:
      framework: "@modelcontextprotocol/sdk with manual registration"
      location: "Inferred from TypeScript SDK patterns"
      
      tool_registration:
        pattern: "Manual registration via server.setRequestHandler"
        list_tools: |
          server.setRequestHandler(ListToolsRequestSchema, async () => ({
            tools: [
              {
                name: 'index_codebase',
                description: 'Index a codebase directory',
                inputSchema: {
                  type: 'object',
                  properties: {
                    path: { type: 'string', description: '...' },
                    force: { type: 'boolean' }
                  },
                  required: ['path']
                }
              },
              // ... other tools
            ]
          }));
        
        call_tool: |
          server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;
            
            switch (name) {
              case 'index_codebase':
                return await handleIndexCodebase(args);
              case 'search_code':
                return await handleSearchCode(args);
              // ... other cases
            }
          });
      
      parameter_definition:
        pattern: "JSON Schema defined inline or via Zod"
        example: |
          inputSchema: {
            type: 'object',
            properties: {
              path: { 
                type: 'string',
                description: 'Absolute path to codebase'
              },
              query: {
                type: 'string',
                description: 'Natural language search query'
              },
              limit: {
                type: 'number',
                default: 10,
                maximum: 50
              }
            },
            required: ['path', 'query']
          }
      
      return_values:
        success_pattern: |
          return {
            content: [
              {
                type: 'text',
                text: 'Search results...'
              }
            ]
          };
        
        error_pattern: |
          throw new McpError(
            ErrorCode.InvalidParams,
            'Error message'
          );
      
      total_tools: 4
      tool_list:
        - name: "index_codebase"
          description: "Index a codebase with Merkle tree change detection"
        - name: "search_code"
          description: "Semantic search using vector embeddings"
        - name: "get_indexing_status"
          description: "Check indexing progress"
        - name: "clear_index"
          description: "Remove indexed codebase"

  # ============================================================================
  # 3. REQUEST/RESPONSE HANDLING
  # ============================================================================
  
  request_response_handling:
    
    rust_code_mcp:
      protocol: "JSON-RPC 2.0 over stdio"
      
      request_flow:
        step_1_receive:
          description: "rmcp stdio() transport reads from stdin"
          format: "Newline-delimited JSON"
          
        step_2_deserialize:
          description: "rmcp automatically deserializes to request types"
          framework_handled: true
          
        step_3_route:
          description: "ToolRouter (macro-generated) routes to correct method"
          code_location: "Generated by #[tool_router]"
          mechanism: "Pattern matching on tool name"
          
        step_4_extract_params:
          description: "Parameters<T> wrapper extracts and validates"
          type_safety: "Compile-time checked"
          validation: "serde deserialize + JSON schema validation"
          
        step_5_execute:
          description: "Tool method executes business logic"
          async: "All tool methods are async"
          
        step_6_format_response:
          description: "Return CallToolResult with Content"
          types:
            - "CallToolResult::success(Vec<Content>)"
            - "Content::text(String)"
          
        step_7_serialize:
          description: "rmcp serializes to JSON-RPC response"
          framework_handled: true
          
        step_8_send:
          description: "Write to stdout"
          format: "Newline-delimited JSON"
      
      error_handling:
        parameter_validation:
          code: |
            if !dir_path.is_dir() {
                return Err(McpError::invalid_params(
                    format!("'{}' is not a directory", directory),
                    None
                ));
            }
          error_type: "McpError::invalid_params"
          
        business_logic_errors:
          code: |
            indexer.index_directory(dir_path)
                .await
                .map_err(|e| McpError::invalid_params(
                    format!("Indexing failed: {}", e),
                    None
                ))?
          pattern: "Convert Result<T, E> to Result<T, McpError>"
          
        internal_errors:
          code: |
            McpError::internal_error(
                format!("Unexpected error: {}", e),
                None
            )
      
      parallel_execution:
        enabled: true
        example: |
          let (vector_future, bm25_future) = tokio::join!(
              self.vector_search.search(query, limit),
              tokio::task::spawn_blocking(move || {
                  bm25_clone.search(&query_clone, limit)
              })
          );
        benefit: "BM25 + Vector search execute concurrently"
    
    claude_context:
      protocol: "JSON-RPC 2.0 over stdio"
      
      request_flow:
        step_1_receive:
          description: "StdioServerTransport reads from stdin"
          format: "Newline-delimited JSON"
          
        step_2_deserialize:
          description: "SDK deserializes to request schema"
          framework_handled: true
          
        step_3_route:
          description: "Server dispatches to registered handler"
          mechanism: "Handler map keyed by schema"
          
        step_4_extract_params:
          description: "Manual extraction from request.params"
          type_safety: "Runtime validation via Zod (if used)"
          
        step_5_execute:
          description: "Handler function executes business logic"
          async: "All handlers are async"
          
        step_6_format_response:
          description: "Return object with content array"
          types:
            - "{ content: [{ type: 'text', text: '...' }] }"
          
        step_7_serialize:
          description: "SDK serializes to JSON-RPC response"
          framework_handled: true
          
        step_8_send:
          description: "Write to stdout"
          format: "Newline-delimited JSON"
      
      error_handling:
        pattern: "Throw McpError with error codes"
        example: |
          if (!fs.existsSync(path)) {
            throw new McpError(
              ErrorCode.InvalidParams,
              `Path does not exist: ${path}`
            );
          }
        
        error_codes:
          - "ErrorCode.InvalidParams"
          - "ErrorCode.InternalError"
          - "ErrorCode.MethodNotFound"

  # ============================================================================
  # 4. STDIO TRANSPORT
  # ============================================================================
  
  stdio_transport:
    
    rust_code_mcp:
      import: "use rmcp::transport::stdio;"
      usage: "src/main.rs:31"
      initialization: |
        let service = SearchTool::with_sync_manager(sync_manager)
            .serve(stdio())
            .await?;
      
      characteristics:
        stdin: "Read JSON-RPC requests (newline-delimited)"
        stdout: "Write JSON-RPC responses (newline-delimited)"
        stderr: "Write logs (tracing framework)"
        blocking: "service.waiting().await blocks until shutdown"
        
      logging_separation:
        code: "src/main.rs:9-13"
        configuration: |
          tracing_subscriber::fmt()
              .with_writer(std::io::stderr)  // Logs to stderr
              .with_ansi(false)              // No color codes
              .init();
        rationale: "Keep stdout clean for JSON-RPC protocol"
      
      message_format:
        request_example: |
          {"jsonrpc":"2.0","method":"tools/call","params":{"name":"search","arguments":{"directory":"/path","keyword":"async"}},"id":1}
        response_example: |
          {"jsonrpc":"2.0","result":{"content":[{"type":"text","text":"Found 5 results..."}]},"id":1}
        delimiter: "Newline (\\n)"
      
      framework_abstraction:
        level: "High - rmcp handles all transport details"
        developer_responsibility: "Only implement tool methods"
    
    claude_context:
      import: "import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';"
      usage: "Likely in server initialization"
      initialization: |
        const transport = new StdioServerTransport();
        await server.connect(transport);
      
      characteristics:
        stdin: "Read JSON-RPC requests"
        stdout: "Write JSON-RPC responses"
        stderr: "Write logs (console.error)"
        blocking: "Process runs until stdin closes"
      
      message_format:
        same_as: "rust-code-mcp (JSON-RPC 2.0 standard)"
        delimiter: "Newline"
      
      framework_abstraction:
        level: "High - SDK handles transport"
        developer_responsibility: "Register handlers, implement tool logic"

  # ============================================================================
  # 5. TOOL REGISTRATION PATTERNS
  # ============================================================================
  
  tool_registration:
    
    rust_code_mcp:
      mechanism: "Macro-based automatic registration"
      
      registration_flow:
        compile_time:
          step_1: "#[tool_router] macro scans all #[tool] methods"
          step_2: "Generates ToolRouter<SearchTool> impl"
          step_3: "Creates routing table mapping tool names to methods"
          step_4: "Generates JSON schemas from parameter structs"
        
        runtime:
          step_1: "SearchTool::tool_router() called in constructor"
          step_2: "Returns pre-generated ToolRouter"
          step_3: "No dynamic registration needed"
      
      tool_discovery:
        mechanism: "ServerHandler::get_info() returns tool list"
        location: "src/tools/search_tool.rs:985-1000"
        automatic: "Tools automatically listed from router"
      
      benefits:
        - "Zero-cost abstraction (compile-time only)"
        - "Type-safe routing"
        - "Impossible to register tool without implementing method"
        - "Automatic JSON schema generation"
        - "No runtime reflection"
      
      trade_offs:
        - "Requires proc macro understanding"
        - "Less flexible than runtime registration"
        - "Cannot add tools dynamically"
    
    claude_context:
      mechanism: "Manual runtime registration"
      
      registration_flow:
        runtime:
          step_1: "Create Server instance"
          step_2: "Call server.setRequestHandler(ListToolsRequestSchema, ...)"
          step_3: "Return array of tool definitions with schemas"
          step_4: "Call server.setRequestHandler(CallToolRequestSchema, ...)"
          step_5: "Implement switch/case or handler map"
      
      tool_discovery:
        mechanism: "ListToolsRequestSchema handler"
        pattern: |
          server.setRequestHandler(ListToolsRequestSchema, async () => ({
            tools: [
              {
                name: 'search_code',
                description: '...',
                inputSchema: { ... }
              },
              // ...
            ]
          }));
      
      benefits:
        - "Explicit and visible"
        - "Can add tools dynamically"
        - "Standard JavaScript patterns"
        - "Easy to understand for TypeScript developers"
      
      trade_offs:
        - "Boilerplate (manual schema definitions)"
        - "Runtime overhead"
        - "Possible mismatch between tool list and implementation"
        - "No compile-time verification"

  # ============================================================================
  # 6. TYPE SAFETY AND VALIDATION
  # ============================================================================
  
  type_safety:
    
    rust_code_mcp:
      compile_time_guarantees:
        - "Parameter types checked at compile time"
        - "Impossible to call tool with wrong types"
        - "Exhaustive pattern matching on enums"
        - "Lifetime and ownership checked"
      
      parameter_extraction:
        mechanism: "Parameters<T> wrapper + serde"
        validation_layers:
          layer_1_json_schema:
            description: "Client-side validation via schemars-generated schema"
            location: "In tool description metadata"
          
          layer_2_deserialization:
            description: "serde::Deserialize validates structure"
            error: "Returns McpError::invalid_params on failure"
          
          layer_3_business_logic:
            description: "Additional validation in tool method"
            example: |
              if keyword.trim().is_empty() {
                  return Err(McpError::invalid_params(
                      "Search keyword is empty",
                      None
                  ));
              }
      
      error_propagation:
        pattern: "Result<T, E> with ? operator"
        conversion: ".map_err(|e| McpError::...)"
        example: |
          let indexer = UnifiedIndexer::new(...)
              .await
              .map_err(|e| McpError::invalid_params(
                  format!("Failed to initialize: {}", e),
                  None
              ))?;
    
    claude_context:
      runtime_validation:
        mechanism: "JSON Schema + optional Zod"
        validation_layers:
          layer_1_json_schema:
            description: "SDK validates against declared inputSchema"
            error: "Throws McpError if validation fails"
          
          layer_2_zod:
            description: "Optional: Zod schema validation"
            example: |
              const SearchParamsSchema = z.object({
                path: z.string(),
                query: z.string(),
                limit: z.number().min(1).max(50).default(10)
              });
              
              const params = SearchParamsSchema.parse(request.params.arguments);
          
          layer_3_business_logic:
            description: "Additional validation in handler"
            example: |
              if (!fs.existsSync(params.path)) {
                throw new McpError(
                  ErrorCode.InvalidParams,
                  'Path does not exist'
                );
              }
      
      error_propagation:
        pattern: "try/catch with thrown McpError"
        example: |
          try {
            const results = await searchCodebase(params);
            return { content: [...] };
          } catch (error) {
            throw new McpError(
              ErrorCode.InternalError,
              error.message
            );
          }

  # ============================================================================
  # 7. DEPENDENCY INJECTION & STATE MANAGEMENT
  # ============================================================================
  
  state_management:
    
    rust_code_mcp:
      pattern: "Constructor injection with Arc<T> for shared state"
      
      tool_struct_state:
        fields:
          - name: "tool_router"
            type: "ToolRouter<Self>"
            purpose: "Generated routing logic"
          
          - name: "sync_manager"
            type: "Option<Arc<SyncManager>>"
            purpose: "Optional background sync service"
      
      constructors:
        basic:
          code: |
            pub fn new() -> Self {
                Self {
                    tool_router: Self::tool_router(),
                    sync_manager: None,
                }
            }
        
        with_dependencies:
          code: |
            pub fn with_sync_manager(sync_manager: Arc<SyncManager>) -> Self {
                Self {
                    tool_router: Self::tool_router(),
                    sync_manager: Some(sync_manager),
                }
            }
      
      usage_in_tools:
        example: |
          if let Some(ref sync_mgr) = self.sync_manager {
              sync_mgr.track_directory(dir_path.to_path_buf()).await;
          }
        benefit: "Optional dependencies, degraded functionality if absent"
      
      thread_safety:
        mechanism: "Arc<T> for shared ownership across tokio tasks"
        example_from_main: |
          let sync_manager = Arc::new(SyncManager::with_defaults(300));
          tokio::spawn(async move {
              sync_manager_clone.run().await;
          });
    
    claude_context:
      pattern: "Module-level singletons or closure-captured state"
      
      typical_pattern:
        code: |
          // Module-level state
          let milvusClient: MilvusClient;
          let embeddingProvider: EmbeddingProvider;
          
          // Handlers have access via closure
          server.setRequestHandler(CallToolRequestSchema, async (request) => {
            // Use milvusClient, embeddingProvider
          });
      
      initialization:
        description: "State initialized before server start"
        example: |
          const milvusClient = new MilvusClient({
            address: process.env.MILVUS_ADDRESS,
            token: process.env.MILVUS_TOKEN
          });
          
          const embeddingProvider = new OpenAIEmbeddingProvider(
            process.env.OPENAI_API_KEY
          );

  # ============================================================================
  # 8. KEY ARCHITECTURAL DIFFERENCES
  # ============================================================================
  
  architectural_differences:
    
    tool_definition_approach:
      rust_code_mcp:
        style: "Object-oriented with macro-generated dispatch"
        code_organization: "Methods on SearchTool struct"
        registration: "Compile-time via #[tool_router]"
        boilerplate: "Minimal (macros handle)"
      
      claude_context:
        style: "Functional with manual dispatch"
        code_organization: "Separate handler functions"
        registration: "Runtime via setRequestHandler"
        boilerplate: "Moderate (manual schemas + switch cases)"
    
    type_safety:
      rust_code_mcp:
        enforcement: "Compile-time"
        mechanism: "Rust type system + serde + schemars"
        errors_caught: "At compile time"
      
      claude_context:
        enforcement: "Runtime"
        mechanism: "JSON Schema + optional Zod"
        errors_caught: "At runtime"
    
    async_model:
      rust_code_mcp:
        runtime: "tokio (Rust async/await)"
        concurrency: "Explicit with tokio::spawn, tokio::join!"
        structured_concurrency: "Via tokio task management"
      
      claude_context:
        runtime: "Node.js event loop (async/await)"
        concurrency: "Promise.all for parallel operations"
        structured_concurrency: "Via Promise combinators"
    
    error_handling:
      rust_code_mcp:
        philosophy: "Errors as values (Result<T, E>)"
        propagation: "? operator"
        conversion: ".map_err()"
      
      claude_context:
        philosophy: "Exceptions (throw/catch)"
        propagation: "try/catch blocks"
        conversion: "Manual error type mapping"
    
    dependency_management:
      rust_code_mcp:
        mechanism: "Constructor injection + Arc<T>"
        lifetime: "Explicit (owned, borrowed, Arc)"
        thread_safety: "Compile-time enforced (Send + Sync)"
      
      claude_context:
        mechanism: "Closure capture or dependency injection"
        lifetime: "Garbage collected"
        thread_safety: "Runtime (Node.js single-threaded)"

  # ============================================================================
  # 9. PERFORMANCE IMPLICATIONS
  # ============================================================================
  
  performance_implications:
    
    rust_code_mcp:
      startup_time:
        compile_time_overhead: "Higher (macro expansion)"
        runtime_overhead: "Near zero (pre-generated routing)"
      
      request_latency:
        deserialization: "Fast (serde + zero-copy when possible)"
        routing: "O(1) via generated match"
        execution: "Native compiled code"
        serialization: "Fast (serde)"
      
      memory_usage:
        tool_router: "Minimal (compile-time generated)"
        async_runtime: "tokio overhead (work-stealing)"
        per_request: "Stack-allocated when possible"
      
      concurrency:
        model: "Multi-threaded tokio runtime"
        parallel_tools: "Can execute tools concurrently"
        blocking_operations: "tokio::task::spawn_blocking"
    
    claude_context:
      startup_time:
        compile_time_overhead: "None (interpreted)"
        runtime_overhead: "Module loading + initialization"
      
      request_latency:
        deserialization: "Fast (V8 JSON.parse)"
        routing: "O(1) hash map lookup or switch"
        execution: "JIT-compiled JavaScript"
        serialization: "Fast (V8 JSON.stringify)"
      
      memory_usage:
        tool_handlers: "Closure overhead"
        async_runtime: "Node.js event loop"
        per_request: "Heap-allocated objects"
      
      concurrency:
        model: "Single-threaded event loop"
        parallel_tools: "Via async but not truly parallel"
        blocking_operations: "Worker threads if needed"

  # ============================================================================
  # 10. SDK FEATURE COMPARISON
  # ============================================================================
  
  sdk_features:
    
    rmcp_rust_sdk:
      repository: "https://github.com/modelcontextprotocol/rust-sdk"
      maturity: "In development"
      
      features:
        - "Procedural macros for tool definition"
        - "Type-safe parameter extraction"
        - "Automatic JSON schema generation"
        - "stdio transport built-in"
        - "ServerHandler trait for customization"
        - "Integration with serde ecosystem"
      
      strengths:
        - "Zero-cost abstractions"
        - "Compile-time safety"
        - "Excellent for performance-critical applications"
        - "Native async/await support"
      
      limitations:
        - "Learning curve for proc macros"
        - "Less ecosystem maturity than TypeScript SDK"
        - "Fewer examples and resources"
    
    modelcontextprotocol_sdk_typescript:
      repository: "https://github.com/modelcontextprotocol/typescript-sdk"
      maturity: "More mature"
      
      features:
        - "Manual tool registration"
        - "JSON Schema validation"
        - "stdio transport built-in"
        - "Multiple transport options"
        - "Extensive TypeScript types"
        - "Integration with Node.js ecosystem"
      
      strengths:
        - "Familiar JavaScript patterns"
        - "Large ecosystem of npm packages"
        - "More examples and documentation"
        - "Easier to get started"
      
      limitations:
        - "Runtime overhead"
        - "No compile-time guarantees"
        - "More boilerplate code"

  # ============================================================================
  # 11. CODE ORGANIZATION PATTERNS
  # ============================================================================
  
  code_organization:
    
    rust_code_mcp:
      structure:
        root: "src/"
        tools_module: "src/tools/"
        files:
          - "src/tools/mod.rs (module exports)"
          - "src/tools/search_tool.rs (main tools: 10 tools)"
          - "src/tools/index_tool.rs (indexing logic)"
          - "src/tools/health_tool.rs (health check)"
      
      pattern: "One struct with all related tools as methods"
      
      benefits:
        - "Shared state via &self"
        - "Consistent interface"
        - "Easier dependency injection"
      
      tool_separation:
        primary_tools: "Implemented as SearchTool methods"
        delegated_tools:
          - "health_check delegates to health_tool::health_check"
          - "index_codebase delegates to index_tool::index_codebase"
        rationale: "Keep SearchTool focused while allowing modular logic"
    
    claude_context:
      structure:
        root: "src/"
        likely_pattern: "Separate files per tool or tool category"
      
      typical_organization:
        - "src/server.ts (main server setup)"
        - "src/tools/index.ts (tool registration)"
        - "src/tools/search.ts (search handler)"
        - "src/tools/index-codebase.ts (indexing handler)"
      
      pattern: "Separate handler functions per tool"
      
      benefits:
        - "Clear separation of concerns"
        - "Easy to add/remove tools"
        - "Standard Node.js module pattern"

  # ============================================================================
  # 12. TESTING APPROACHES
  # ============================================================================
  
  testing:
    
    rust_code_mcp:
      unit_tests:
        location: "End of tool files (e.g., index_tool.rs:205-284)"
        pattern: "#[cfg(test)] mod tests"
        framework: "Built-in Rust test framework"
        async_support: "#[tokio::test]"
        
        example: |
          #[tokio::test]
          async fn test_index_codebase_invalid_directory() {
              let params = IndexCodebaseParams {
                  directory: "/nonexistent/path".to_string(),
                  force_reindex: None,
              };
              let result = index_codebase(params, None).await;
              assert!(result.is_err());
          }
      
      integration_tests:
        location: "tests/ directory"
        examples:
          - "tests/test_index_tool_integration.rs"
          - "tests/test_hybrid_search.rs"
          - "tests/test_full_incremental_flow.rs"
      
      test_attributes:
        - "#[tokio::test] for async tests"
        - "#[ignore] for tests requiring external services (Qdrant)"
        - "use tempfile for temporary test directories"
    
    claude_context:
      likely_approach:
        unit_tests: "Jest or Mocha"
        mocking: "Sinon or Jest mocks"
        async: "async/await in test functions"
        
        example: |
          describe('search_code tool', () => {
            it('should return search results', async () => {
              const result = await handleSearchCode({
                path: '/test/path',
                query: 'async function',
                limit: 10
              });
              expect(result.content).toBeDefined();
            });
          });

  # ============================================================================
  # 13. PRACTICAL EXAMPLES
  # ============================================================================
  
  practical_examples:
    
    example_1_simple_tool:
      rust_code_mcp: |
        #[tool(description = "Read file content")]
        async fn read_file_content(
            &self,
            Parameters(FileContentParams { file_path }): Parameters<FileContentParams>,
        ) -> Result<CallToolResult, McpError> {
            let path = Path::new(&file_path);
            
            if !path.exists() {
                return Err(McpError::invalid_params(
                    format!("File '{}' does not exist", file_path),
                    None
                ));
            }
            
            let content = fs::read_to_string(path)
                .map_err(|e| McpError::invalid_params(e.to_string(), None))?;
            
            Ok(CallToolResult::success(vec![Content::text(content)]))
        }
      
      claude_context: |
        {
          name: 'read_file',
          description: 'Read file content',
          inputSchema: {
            type: 'object',
            properties: {
              filePath: { type: 'string' }
            },
            required: ['filePath']
          }
        }
        
        // Handler
        case 'read_file':
          const { filePath } = args;
          
          if (!fs.existsSync(filePath)) {
            throw new McpError(
              ErrorCode.InvalidParams,
              `File does not exist: ${filePath}`
            );
          }
          
          const content = await fs.promises.readFile(filePath, 'utf-8');
          return {
            content: [{ type: 'text', text: content }]
          };
    
    example_2_tool_with_dependencies:
      rust_code_mcp: |
        async fn search(
            &self,
            Parameters(SearchParams { directory, keyword }): Parameters<SearchParams>,
        ) -> Result<CallToolResult, McpError> {
            // ... indexing logic ...
            
            // Track directory if sync manager available
            if let Some(ref sync_mgr) = self.sync_manager {
                sync_mgr.track_directory(dir_path.to_path_buf()).await;
                tracing::info!("Directory tracked for background sync");
            }
            
            // ... search logic ...
        }
      
      claude_context: |
        // State captured in closure
        const milvusClient = new MilvusClient(config);
        
        server.setRequestHandler(CallToolRequestSchema, async (request) => {
          if (request.params.name === 'search_code') {
            const { path, query, limit } = request.params.arguments;
            
            // Use captured milvusClient
            const results = await milvusClient.search({
              collection_name: getCollectionName(path),
              vectors: [embedding],
              limit
            });
            
            return { content: [{ type: 'text', text: formatResults(results) }] };
          }
        });
    
    example_3_parallel_operations:
      rust_code_mcp: |
        // Parallel BM25 + Vector search
        let (vector_future, bm25_future) = tokio::join!(
            self.vector_search.search(query, limit),
            tokio::task::spawn_blocking(move || {
                bm25_clone.search(&query_clone, limit)
            })
        );
        
        let vector_results = vector_future?;
        let bm25_results = bm25_future??;
        
        // RRF fusion
        let hybrid_results = rrf_fusion(bm25_results, vector_results);
      
      claude_context: |
        // Parallel operations with Promise.all
        const [vectorResults, bm25Results] = await Promise.all([
          vectorSearch(query, limit),
          bm25Search(query, limit)
        ]);
        
        // Combine results
        const hybridResults = rrfFusion(bm25Results, vectorResults);

  # ============================================================================
  # 14. RECOMMENDATIONS & BEST PRACTICES
  # ============================================================================
  
  recommendations:
    
    when_to_use_rust_approach:
      scenarios:
        - "Performance-critical applications"
        - "Type safety is paramount"
        - "Complex concurrent operations"
        - "Low-level system integration"
        - "Long-running server processes"
      
      benefits:
        - "Compile-time error detection"
        - "Zero-cost abstractions"
        - "Excellent async performance"
        - "Memory safety guarantees"
    
    when_to_use_typescript_approach:
      scenarios:
        - "Rapid prototyping"
        - "Team familiar with JavaScript/TypeScript"
        - "Integration with Node.js ecosystem"
        - "Frequent schema changes"
        - "Scripting-style applications"
      
      benefits:
        - "Faster development iteration"
        - "Larger ecosystem"
        - "More accessible to web developers"
        - "Dynamic tool registration"
    
    hybrid_approach_possibilities:
      concept: "Implement performance-critical tools in Rust, orchestration in TypeScript"
      pattern: "Use Rust for indexing/search, TypeScript for API layer"
      communication: "Native modules (napi-rs) or subprocess communication"

  # ============================================================================
  # 15. CONCLUSION
  # ============================================================================
  
  conclusion:
    summary: |
      Both rust-code-mcp (rmcp SDK) and claude-context (@modelcontextprotocol/sdk) 
      implement the Model Context Protocol effectively, but with fundamentally 
      different approaches reflecting their language ecosystems.
    
    rust_code_mcp_philosophy:
      - "Compile-time safety over runtime flexibility"
      - "Zero-cost abstractions via procedural macros"
      - "Explicit concurrency with tokio"
      - "Type-driven development"
    
    claude_context_philosophy:
      - "Runtime flexibility over compile-time constraints"
      - "Manual but explicit tool registration"
      - "Event-loop concurrency with Node.js"
      - "Dynamic typing with optional static analysis"
    
    key_takeaways:
      rust_advantages:
        - "Superior type safety and compile-time guarantees"
        - "Better performance for CPU-intensive operations"
        - "Macro system reduces boilerplate"
        - "Explicit async/await with true parallelism"
      
      typescript_advantages:
        - "Faster development and iteration"
        - "More accessible to broader developer audience"
        - "Richer ecosystem for web integrations"
        - "Dynamic tool registration flexibility"
      
      convergence_points:
        - "Both use JSON-RPC 2.0 over stdio"
        - "Both support async tool execution"
        - "Both provide JSON Schema validation"
        - "Both follow MCP specification"
    
    recommendation:
      choice_factors:
        - "Team expertise and preferences"
        - "Performance requirements"
        - "Development velocity needs"
        - "Type safety requirements"
        - "Integration ecosystem"
      
      pragmatic_approach: |
        Choose based on project constraints:
        - Rust (rmcp) for performance-critical, type-safe, production systems
        - TypeScript (SDK) for rapid development, web integration, broader team
        
        Consider hybrid approach for best of both worlds.

  # ============================================================================
  # APPENDIX: CODE REFERENCES
  # ============================================================================
  
  code_references:
    rust_code_mcp:
      main_entry: "src/main.rs:7-39"
      tool_definitions: "src/tools/search_tool.rs:156-1001"
      parameter_structs: "src/tools/search_tool.rs:27-93"
      server_handler: "src/tools/search_tool.rs:983-1000"
      cargo_dependencies: "Cargo.toml:8-11"
    
    claude_context:
      note: "Code inferred from @modelcontextprotocol/sdk patterns and documentation"
      sdk_repo: "https://github.com/modelcontextprotocol/typescript-sdk"
      reference_implementation: "github.com/zilliztech/claude-context"