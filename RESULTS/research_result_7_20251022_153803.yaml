architectural_comparison:
  project_overview:
    rust_code_mcp:
      name: "file-search-mcp"
      language: "Rust"
      edition: "2024"
      architecture_type: "Single binary + library (monolithic with modular structure)"
      total_lines: 10030
      files_count: 30+
      primary_purpose: "Local-first code search with hybrid BM25 + semantic vector search"
      deployment: "Standalone MCP server binary"
      
    claude_context:
      name: "claude-context"
      language: "TypeScript"
      architecture_type: "Monorepo with core/mcp/extensions packages"
      primary_purpose: "Cloud-first semantic code search with Merkle tree change detection"
      deployment: "NPM packages + VSCode extension"
      packages:
        - "@zilliz/claude-context-core"
        - "@zilliz/claude-context-mcp"
        - "semanticcodesearch (VSCode extension)"

  code_organization:
    rust_code_mcp:
      structure_type: "Rust module hierarchy with cargo workspace"
      organization_pattern: "Feature-based modules"
      module_count: 11
      entry_points:
        - path: "src/main.rs"
          lines: 40
          purpose: "MCP server entry point with tokio runtime"
        - path: "src/lib.rs"
          lines: 16
          purpose: "Library exports for all public modules"
        - path: "src/bin/test_tools_direct.rs"
          purpose: "Direct tool testing binary"
      
      module_hierarchy:
        core_modules:
          - name: "schema"
            lines: 241
            responsibility: "Tantivy schema definitions"
            coupling: "Low - used by indexing layer"
          
          - name: "metadata_cache"
            lines: 250
            responsibility: "File metadata tracking with sled KV store"
            coupling: "Medium - used by indexing for change detection"
        
        parsing_layer:
          - name: "parser"
            files: 4
            total_lines: 1915
            responsibility: "Rust code analysis via tree-sitter"
            submodules:
              - "mod.rs (807 lines) - Core parsing logic"
              - "call_graph.rs (305 lines) - Function call relationships"
              - "imports.rs (269 lines) - Dependency extraction"
              - "type_references.rs (534 lines) - Type usage tracking"
            coupling: "Low - independent of storage"
            
        data_processing:
          - name: "chunker"
            lines: 485
            responsibility: "Semantic code chunking with contextual retrieval"
            coupling: "Low - consumes ParseResult, produces CodeChunk"
            
          - name: "embeddings"
            lines: 288
            responsibility: "Vector generation via fastembed (local ONNX)"
            coupling: "Medium - uses Arc<Model> for sharing"
            
        storage_layer:
          - name: "indexing"
            files: 5
            total_lines: 1715
            submodules:
              - "unified.rs (642 lines) - Tantivy + Qdrant orchestration"
              - "incremental.rs (384 lines) - Change detection indexing"
              - "merkle.rs (439 lines) - Merkle tree for 100x speedup"
              - "bulk.rs (238 lines) - Batch operations with HNSW"
            responsibility: "Populate both BM25 and vector indices"
            coupling: "High - coordinates parser, chunker, embeddings"
            
          - name: "vector_store"
            files: 2
            lines: 791
            responsibility: "Qdrant vector database client"
            coupling: "Medium - uses Arc<QdrantClient>"
            
        retrieval_layer:
          - name: "search"
            files: 4
            total_lines: 1520
            submodules:
              - "mod.rs (549 lines) - Hybrid search orchestration"
              - "bm25.rs (303 lines) - Tantivy full-text search"
              - "resilient.rs (222 lines) - Fallback strategies"
              - "rrf_tuner.rs (446 lines) - Reciprocal Rank Fusion tuning"
            responsibility: "Combine BM25 + vector results via RRF"
            coupling: "High - depends on Tantivy + Qdrant"
            
        integration_layer:
          - name: "tools"
            files: 3
            lines: 1428
            submodules:
              - "search_tool.rs (1000 lines) - MCP tool implementations"
              - "index_tool.rs (284 lines) - Manual indexing trigger"
              - "health_tool.rs (144 lines) - Health checks"
            responsibility: "MCP protocol implementation"
            coupling: "Very High - depends on all layers"
            
          - name: "mcp"
            files: 2
            lines: 306
            responsibility: "Background sync manager (5-min intervals)"
            coupling: "High - uses IncrementalIndexer"
            
        cross_cutting:
          - name: "security"
            files: 2
            lines: 449
            responsibility: "Sensitive file filtering + secret detection"
            coupling: "Low - used by indexing pipeline"
            
          - name: "monitoring"
            files: 2
            lines: 465
            responsibility: "Health checks + backup management"
            coupling: "Low - read-only system inspection"
      
      dependency_management:
        strategy: "Cargo.toml with explicit version constraints"
        external_crates: 25+
        key_dependencies:
          protocol:
            - "rmcp (git-based MCP SDK)"
            - "tokio (async runtime with multi-thread)"
          
          code_analysis:
            - "tree-sitter 0.20"
            - "tree-sitter-rust 0.20"
          
          search_indexing:
            - "tantivy 0.22.0 (BM25)"
            - "qdrant-client 1 (vectors)"
            - "fastembed 4 (local embeddings)"
          
          data_processing:
            - "text-splitter 0.13"
            - "serde_json 1.0"
            - "bincode 1.3"
          
          change_detection:
            - "sled 0.34 (embedded KV)"
            - "sha2 0.10 (hashing)"
            - "rs_merkle 1.4 (merkle trees)"
            - "notify 6 (file watching)"
            - "walkdir 2"
          
          utilities:
            - "regex 1"
            - "glob 0.3"
            - "anyhow 1"
            - "tracing 0.1"
      
      configuration:
        method: "XDG Base Directory compliant"
        data_directories:
          - "~/.local/share/rust-code-mcp/search/index/ (Tantivy)"
          - "~/.local/share/rust-code-mcp/search/cache/ (sled)"
          - "~/.local/share/rust-code-mcp/search/merkle/ (snapshots)"
        qdrant_config:
          default_url: "http://localhost:6334 (gRPC)"
          collection_naming: "code_chunks_{sanitized_project_name}"
          vector_dimensions: 384
        
    claude_context:
      structure_type: "TypeScript monorepo with workspaces"
      organization_pattern: "Package-based with clear separation"
      packages:
        core:
          name: "@zilliz/claude-context-core"
          responsibility: "Core indexing and search logic"
          exports:
            - "MerkleIndexer"
            - "ASTChunker"
            - "EmbeddingGenerator (OpenAI/Voyage/Ollama)"
            - "MilvusClient"
          coupling: "Low - independent business logic"
        
        mcp:
          name: "@zilliz/claude-context-mcp"
          responsibility: "MCP protocol adapter"
          exports:
            - "MCPServer"
            - "SearchTool"
            - "SyncManager"
          coupling: "High - depends on core package"
        
        extensions:
          name: "semanticcodesearch"
          responsibility: "VSCode IDE integration"
          exports:
            - "VSCode extension commands"
            - "UI components"
          coupling: "Medium - uses mcp package"
      
      dependency_management:
        strategy: "NPM workspace with shared dependencies"
        key_dependencies:
          protocol:
            - "@modelcontextprotocol/sdk"
          
          code_analysis:
            - "tree-sitter"
            - "tree-sitter language packages"
          
          embeddings:
            - "openai SDK"
            - "voyage-ai SDK"
            - "ollama API client"
          
          vector_db:
            - "@zilliz/milvus2-sdk-node"
          
          chunking:
            - "langchain RecursiveCharacterTextSplitter"
          
          change_detection:
            - "merkle-lib"
            - "crypto (SHA-256)"
      
      configuration:
        method: "~/.context/ directory"
        data_directories:
          - "~/.context/merkle/ (Merkle snapshots)"
          - "Milvus/Zilliz Cloud (remote vector store)"
        api_keys:
          - "OPENAI_API_KEY"
          - "VOYAGE_API_KEY"
          - "ZILLIZ_ENDPOINT + TOKEN"

  architectural_patterns:
    rust_code_mcp:
      primary_pattern: "Layered architecture with clear boundaries"
      layers:
        - "Entry: main.rs + MCP server"
        - "Protocol: tools/ (MCP implementation)"
        - "Orchestration: search/ + indexing/"
        - "Processing: parser/ + chunker/ + embeddings/"
        - "Storage: vector_store/ + Tantivy + metadata_cache"
        - "Cross-cutting: security/ + monitoring/"
      
      design_principles:
        separation_of_concerns:
          rating: "Excellent"
          evidence:
            - "Parser independent of storage"
            - "Chunker decoupled from indexing"
            - "Search independent of indexing strategy"
            - "Security filters applied at ingestion boundary"
        
        trait_abstraction:
          rating: "Good"
          patterns:
            - "ServerHandler for MCP protocol"
            - "EmbeddingModel abstraction"
            - "Index trait for Tantivy"
            - "Client trait for Qdrant"
        
        resource_management:
          rating: "Excellent"
          patterns:
            - "Arc for shared ownership (embeddings, Qdrant client)"
            - "RwLock for concurrent access (SyncManager directories)"
            - "Lazy initialization (Tantivy index, Qdrant collection)"
            - "Tokio async/await for non-blocking I/O"
        
        error_handling:
          rating: "Good"
          patterns:
            - "Result<T> with anyhow::Error"
            - "Resilient search with fallback strategies"
            - "Graceful degradation (BM25-only if vector fails)"
        
        caching_strategy:
          rating: "Good"
          implementation:
            - "Metadata cache (sled) for file hashes"
            - "Merkle tree snapshots for change detection"
            - "Persistent Tantivy indices"
            - "Qdrant vector storage"
      
      data_flow:
        indexing_pipeline:
          steps:
            - "File input → Parser (tree-sitter)"
            - "ParseResult → Chunker (semantic splitting)"
            - "CodeChunk → Security filter (secrets)"
            - "Filtered chunks → Embeddings (fastembed)"
            - "Chunks + vectors → Parallel write:"
            - "  ├─ Tantivy (BM25 index)"
            - "  └─ Qdrant (vector store)"
            - "Update metadata cache (sled)"
          
        search_pipeline:
          steps:
            - "Query text → Parallel search:"
            - "  ├─ VectorSearch: Embed query → Qdrant.search()"
            - "  └─ BM25Search: Parse query → Tantivy.search()"
            - "Ranked results → RRF Fusion"
            - "Merged results → Deduplication"
            - "Return sorted SearchResults"
        
        change_detection:
          strategy: "Merkle tree (100x faster than per-file hashing)"
          steps:
            - "Phase 1: Calculate Merkle root (milliseconds)"
            - "Phase 2: Compare with snapshot"
            - "Phase 3: If unchanged → skip"
            - "Phase 4: If changed → traverse tree"
            - "Phase 5: Identify changed files"
            - "Phase 6: Reindex only changed files"
            - "Phase 7: Save new snapshot"
    
    claude_context:
      primary_pattern: "Package-based architecture with cloud dependencies"
      layers:
        - "Entry: MCP server + VSCode extension"
        - "Protocol: @zilliz/claude-context-mcp"
        - "Core Logic: @zilliz/claude-context-core"
        - "Processing: AST parsing + chunking + embeddings"
        - "Storage: Milvus/Zilliz Cloud (remote)"
      
      design_principles:
        separation_of_concerns:
          rating: "Excellent"
          evidence:
            - "Clear package boundaries (core/mcp/extensions)"
            - "Core logic independent of protocol"
            - "VSCode extension isolated from core"
        
        extensibility:
          rating: "Excellent"
          patterns:
            - "Multiple embedding providers (OpenAI/Voyage/Ollama)"
            - "Multi-language support via tree-sitter parsers"
            - "Pluggable vector stores (Milvus/Zilliz)"
        
        cloud_integration:
          rating: "Excellent"
          patterns:
            - "Managed Milvus/Zilliz Cloud"
            - "API-based embeddings (OpenAI/Voyage)"
            - "Automatic scaling and replication"
        
        state_persistence:
          rating: "Excellent"
          patterns:
            - "Merkle snapshots in ~/.context/merkle/"
            - "Persistent vector store (cloud or self-hosted)"
            - "Survives restarts and crashes"
      
      data_flow:
        indexing_pipeline:
          steps:
            - "File input → tree-sitter parser"
            - "AST → Semantic chunking (functions/classes)"
            - "Fallback: RecursiveCharacterTextSplitter"
            - "Chunks → Embedding API (OpenAI/Voyage/Ollama)"
            - "Embeddings + metadata → Milvus/Zilliz"
            - "Update Merkle snapshot"
        
        search_pipeline:
          steps:
            - "Query text → Embedding API"
            - "Vector → Milvus similarity search"
            - "Return ranked results (vector-only)"
        
        change_detection:
          strategy: "Merkle tree (production-validated)"
          steps:
            - "Phase 1: Rapid Detection (milliseconds)"
            - "  Calculate Merkle root → Compare with snapshot"
            - "  If same → Skip update entirely"
            - "Phase 2: Precise Comparison (seconds)"
            - "  Traverse Merkle tree → Identify changed files"
            - "Phase 3: Incremental Update"
            - "  Parse → Chunk → Embed → Update Milvus"
            - "  Save new Merkle snapshot"

  separation_of_concerns:
    rust_code_mcp:
      rating: "8.5/10"
      strengths:
        - "Clean layer boundaries (parsing → chunking → indexing → search)"
        - "Parser module fully independent of storage"
        - "Security filtering at ingestion boundary"
        - "Monitoring as passive observer"
        - "Metadata cache isolated from business logic"
      
      weaknesses:
        - "SearchTool has high coupling (depends on all layers)"
        - "UnifiedIndexer coordinates many components"
        - "Some cross-cutting concerns (logging, error handling)"
      
      module_responsibility_matrix:
        parser:
          input: "Source code files"
          output: "ParseResult (symbols, call graph, imports)"
          state: "Stateless"
          dependencies: "tree-sitter only"
        
        chunker:
          input: "ParseResult"
          output: "Vec<CodeChunk>"
          state: "Stateless"
          dependencies: "None (pure transformation)"
        
        embeddings:
          input: "CodeChunk"
          output: "Embedding (Vec<f32>)"
          state: "Arc<Model> (shared)"
          dependencies: "fastembed"
        
        indexing:
          input: "Parser + Chunk + Embed outputs"
          output: "Index write side effects"
          state: "Writes to Tantivy + Qdrant"
          dependencies: "All above + storage"
        
        search:
          input: "Query text"
          output: "SearchResult"
          state: "Reads from indices"
          dependencies: "Tantivy + Qdrant"
        
        tools:
          input: "MCP parameters"
          output: "MCP responses"
          state: "Reads/writes all"
          dependencies: "All modules (integration layer)"
    
    claude_context:
      rating: "9/10"
      strengths:
        - "Package-level isolation (core/mcp/extensions)"
        - "Core business logic independent of protocol"
        - "VSCode extension doesn't touch core logic"
        - "Clear public APIs between packages"
        - "Testable units (can test core without MCP)"
      
      weaknesses:
        - "Cloud dependencies reduce portability"
        - "API rate limits affect reliability"
      
      package_responsibility:
        core:
          responsibility: "Indexing, search, change detection"
          external_dependencies: "Minimal (tree-sitter, crypto)"
          testability: "Excellent (unit tests without cloud)"
        
        mcp:
          responsibility: "MCP protocol adapter"
          external_dependencies: "@modelcontextprotocol/sdk + core"
          testability: "Good (mock core for testing)"
        
        extensions:
          responsibility: "IDE integration"
          external_dependencies: "VSCode API + mcp"
          testability: "Medium (requires VSCode runtime)"

  component_coupling:
    rust_code_mcp:
      overall_rating: "Medium coupling with clear interfaces"
      
      loose_coupling:
        - component: "parser"
          reason: "No dependencies on storage or indexing"
          coupling_score: "1/5 (very loose)"
        
        - component: "chunker"
          reason: "Pure transformation, no external state"
          coupling_score: "1/5 (very loose)"
        
        - component: "security"
          reason: "Filter-only, no dependencies on business logic"
          coupling_score: "1/5 (very loose)"
        
        - component: "monitoring"
          reason: "Read-only system inspection"
          coupling_score: "2/5 (loose)"
      
      medium_coupling:
        - component: "embeddings"
          reason: "Arc<Model> shared, but interface clean"
          coupling_score: "3/5 (medium)"
        
        - component: "vector_store"
          reason: "Arc<QdrantClient> shared, async API"
          coupling_score: "3/5 (medium)"
        
        - component: "metadata_cache"
          reason: "Used by indexing, but clear KV interface"
          coupling_score: "3/5 (medium)"
      
      tight_coupling:
        - component: "indexing/unified.rs"
          reason: "Orchestrates parser, chunker, embeddings, storage"
          coupling_score: "4/5 (tight)"
          justification: "Intentional - coordination layer"
        
        - component: "search/mod.rs"
          reason: "Depends on Tantivy + Qdrant + embeddings"
          coupling_score: "4/5 (tight)"
          justification: "Intentional - hybrid search requires both"
        
        - component: "tools/search_tool.rs"
          reason: "Depends on all layers (integration point)"
          coupling_score: "5/5 (very tight)"
          justification: "Acceptable - entry point"
      
      coupling_mitigation:
        strategies:
          - "Trait abstractions for swappable implementations"
          - "Arc for shared ownership without coupling"
          - "Result types for error propagation without exceptions"
          - "Clear module boundaries with pub/private visibility"
    
    claude_context:
      overall_rating: "Low coupling via package boundaries"
      
      package_coupling:
        - from: "extensions"
          to: "mcp"
          type: "Import dependency"
          coupling_score: "2/5 (loose)"
          reason: "Uses public API only"
        
        - from: "mcp"
          to: "core"
          type: "Import dependency"
          coupling_score: "3/5 (medium)"
          reason: "Orchestrates core logic"
        
        - from: "core"
          to: "external APIs"
          type: "Service dependency"
          coupling_score: "4/5 (tight)"
          reason: "OpenAI/Voyage/Milvus APIs"
          risk: "Rate limits, latency, cost"
      
      internal_coupling:
        merkle_indexer:
          dependencies: "crypto (SHA-256), fs"
          coupling_score: "1/5 (very loose)"
        
        ast_chunker:
          dependencies: "tree-sitter, RecursiveCharacterTextSplitter"
          coupling_score: "2/5 (loose)"
        
        embedding_generator:
          dependencies: "OpenAI/Voyage/Ollama SDK"
          coupling_score: "4/5 (tight - cloud)"
          risk: "API availability, cost"
        
        milvus_client:
          dependencies: "@zilliz/milvus2-sdk-node"
          coupling_score: "4/5 (tight - cloud)"
          risk: "Cloud service dependency"

  extensibility:
    rust_code_mcp:
      rating: "7.5/10"
      
      extension_points:
        parsers:
          current: "Rust only (tree-sitter-rust)"
          extensibility: "Good - can add tree-sitter-{lang} crates"
          effort: "Medium (1-2 weeks per language)"
          design: "RustParser is language-specific, needs abstraction"
        
        embeddings:
          current: "fastembed only (all-MiniLM-L6-v2)"
          extensibility: "Good - fastembed supports multiple models"
          effort: "Low (change config)"
          future: "Could add OpenAI/Voyage via trait"
        
        vector_stores:
          current: "Qdrant only"
          extensibility: "Medium - would need trait abstraction"
          effort: "High (2-3 weeks for new backend)"
          design: "VectorStore operations defined, but Qdrant-specific"
        
        search_algorithms:
          current: "BM25 + Vector with RRF"
          extensibility: "Good - RRFTuner is configurable"
          effort: "Low (tune parameters)"
          future: "Could add learning-to-rank"
        
        chunking_strategies:
          current: "text-splitter (token-based)"
          extensibility: "Good - modular design"
          effort: "Medium (AST-first chunking planned)"
          design: "ChunkingStrategy enum can be extended"
        
        deployment_scenarios:
          standalone_binary:
            supported: true
            effort: "Current mode (cargo build --release)"
          
          library_integration:
            supported: true
            effort: "Low (already exports pub modules)"
            use_cases: "Embed in other Rust projects"
          
          docker_container:
            supported: true
            effort: "Low (add Dockerfile)"
            requirements: "Qdrant sidecar or remote"
          
          cloud_deployment:
            supported: true
            effort: "Medium (infrastructure setup)"
            requirements: "Qdrant cluster, persistent storage"
          
          embedded_mode:
            supported: false
            effort: "High (need embedded vector store)"
            blocker: "Qdrant requires separate process"
      
      limitations:
        - "Single language (Rust) - needs multi-language abstraction"
        - "Qdrant dependency - no embedded vector store option"
        - "No plugin system for custom tools"
        - "Hard-coded fastembed model"
    
    claude_context:
      rating: "9/10"
      
      extension_points:
        parsers:
          current: "Multi-language via tree-sitter"
          extensibility: "Excellent - already supports JS, Python, Java, Go, Rust"
          effort: "Low (add tree-sitter parser)"
          design: "Language-agnostic AST chunking"
        
        embeddings:
          current: "OpenAI, Voyage, Ollama"
          extensibility: "Excellent - pluggable providers"
          effort: "Low (implement provider interface)"
          design: "Provider abstraction with API adapters"
        
        vector_stores:
          current: "Milvus/Zilliz"
          extensibility: "Medium - SDK-specific code"
          effort: "High (rewrite client layer)"
          design: "Milvus SDK tightly integrated"
        
        deployment_scenarios:
          npm_package:
            supported: true
            effort: "Current mode (published to NPM)"
          
          vscode_extension:
            supported: true
            effort: "Current mode (marketplace)"
          
          cloud_saas:
            supported: true
            effort: "Native (uses Zilliz Cloud)"
          
          self_hosted:
            supported: true
            effort: "Medium (Milvus installation)"
          
          air_gapped:
            supported: false
            blocker: "Requires API keys (OpenAI/Voyage)"
            workaround: "Use Ollama provider"
      
      strengths:
        - "Multi-language support out-of-box"
        - "Multiple embedding providers"
        - "VSCode integration included"
        - "Cloud-native design"
      
      limitations:
        - "Cloud dependencies reduce offline capability"
        - "API costs scale with usage"
        - "Milvus switching cost high"

  deployment_scenarios:
    rust_code_mcp:
      local_development:
        support: "Excellent"
        setup:
          - "cargo build --release"
          - "Start Qdrant: docker run -p 6333:6333 -p 6334:6334 qdrant/qdrant"
          - "./target/release/file-search-mcp"
        requirements:
          - "Rust toolchain"
          - "Qdrant (Docker or binary)"
          - "~2GB RAM"
        advantages:
          - "100% local, no API keys"
          - "Fast iteration"
          - "Full debugging"
      
      team_shared_server:
        support: "Good"
        setup:
          - "Deploy Qdrant cluster"
          - "Build and run MCP server on shared host"
          - "Team members connect via MCP protocol"
        requirements:
          - "Shared Qdrant instance"
          - "Network access"
          - "Persistent storage"
        advantages:
          - "Centralized indices"
          - "Shared search results"
          - "Cost-effective"
        challenges:
          - "Concurrent write coordination"
          - "Per-user isolation (currently not supported)"
      
      cloud_deployment:
        support: "Good"
        setup:
          - "Deploy Qdrant on cloud (AWS/GCP/Azure)"
          - "Run MCP server as container/VM"
          - "Configure persistent storage for Tantivy indices"
        requirements:
          - "Cloud provider account"
          - "Qdrant cluster or managed service"
          - "Load balancer (optional)"
        advantages:
          - "Scalability"
          - "High availability (with replicas)"
          - "Managed backups"
        challenges:
          - "Network latency to Qdrant"
          - "Cost of cloud resources"
      
      air_gapped_environment:
        support: "Excellent"
        setup:
          - "Offline build: cargo vendor"
          - "Transfer binary + vendor/ to air-gapped host"
          - "Run Qdrant locally"
          - "Pre-download fastembed model"
        requirements:
          - "Pre-staged dependencies"
          - "Local Qdrant"
          - "~500MB for model + binary"
        advantages:
          - "No internet required"
          - "Full data control"
          - "Suitable for classified environments"
        challenges:
          - "Initial setup complexity"
          - "Model updates require re-transfer"
      
      embedded_library:
        support: "Good"
        setup:
          - "Add to Cargo.toml: file-search-mcp = { path = '../file-search-mcp' }"
          - "Use pub modules in your code"
        requirements:
          - "Qdrant accessible (local or remote)"
          - "Tokio async runtime"
        advantages:
          - "Integrate into existing Rust projects"
          - "Reuse search infrastructure"
          - "Programmatic API"
        challenges:
          - "Still requires Qdrant process"
          - "No embedded vector store option"
    
    claude_context:
      local_development:
        support: "Good"
        setup:
          - "npm install -g @zilliz/claude-context-mcp"
          - "Set API keys: OPENAI_API_KEY, ZILLIZ_ENDPOINT, ZILLIZ_TOKEN"
          - "Run MCP server"
        requirements:
          - "Node.js 18+"
          - "API keys"
          - "Internet connection"
        advantages:
          - "NPM installation (simple)"
          - "Multi-language support"
        challenges:
          - "API costs during development"
          - "Internet required"
      
      team_shared_cloud:
        support: "Excellent"
        setup:
          - "Deploy to Zilliz Cloud (managed)"
          - "Share API credentials with team"
          - "VSCode extension auto-connects"
        requirements:
          - "Zilliz Cloud account"
          - "Shared API keys"
        advantages:
          - "Zero infrastructure management"
          - "Elastic scaling"
          - "Multi-replica availability"
          - "Automatic backups"
        challenges:
          - "Subscription cost"
          - "Data sent to cloud (privacy)"
      
      self_hosted_milvus:
        support: "Good"
        setup:
          - "Deploy Milvus cluster (Docker Compose or Helm)"
          - "Point claude-context to self-hosted endpoint"
          - "Use Ollama for local embeddings"
        requirements:
          - "Milvus cluster (memory-intensive)"
          - "Ollama server (for embeddings)"
        advantages:
          - "Data control"
          - "No cloud costs"
        challenges:
          - "Complex Milvus setup"
          - "High memory requirements (8GB+ for Milvus)"
      
      air_gapped_environment:
        support: "Poor"
        blockers:
          - "Requires OpenAI/Voyage API (unless Ollama)"
          - "NPM dependencies need offline install"
          - "Milvus offline install complex"
        workaround:
          - "Use Ollama provider (local embeddings)"
          - "npm install with --offline after vendor"
          - "Self-host Milvus"
        effort: "High (3-5 days setup)"
      
      vscode_integration:
        support: "Excellent"
        setup:
          - "Install semanticcodesearch extension from marketplace"
          - "Configure API keys in VSCode settings"
          - "Right-click code → Search similar"
        requirements:
          - "VSCode"
          - "claude-context-mcp running"
        advantages:
          - "IDE-native experience"
          - "Context menu integration"
          - "Inline search results"

  critical_differences:
    architecture_philosophy:
      rust_code_mcp: "Local-first, self-contained, hybrid search"
      claude_context: "Cloud-first, managed services, vector-only"
    
    data_sovereignty:
      rust_code_mcp:
        embeddings: "100% local (fastembed ONNX)"
        vector_store: "Self-hosted Qdrant"
        code_never_leaves: "Guaranteed"
        suitable_for: "Proprietary codebases, air-gapped, classified"
      
      claude_context:
        embeddings: "Sent to OpenAI/Voyage API (unless Ollama)"
        vector_store: "Zilliz Cloud (or self-hosted Milvus)"
        code_sent_to: "Third-party APIs"
        suitable_for: "Open-source, non-sensitive, cloud-native teams"
    
    cost_model:
      rust_code_mcp:
        initial: "Free (open source)"
        ongoing: "Zero (self-hosted)"
        scaling: "Linear with hardware"
        cost_driver: "Infrastructure only"
      
      claude_context:
        initial: "Free (open source)"
        ongoing: "API costs (OpenAI/Voyage) + Zilliz subscription"
        scaling: "Per-query API costs + storage"
        cost_driver: "Usage-based pricing"
    
    search_approach:
      rust_code_mcp:
        method: "Hybrid (BM25 + vector with RRF fusion)"
        advantage: "Exact keyword matches + semantic similarity"
        quality: "45-50% token reduction (projected)"
      
      claude_context:
        method: "Vector-only (semantic similarity)"
        advantage: "Semantic understanding, meaning-based"
        quality: "40% token reduction (proven)"
    
    change_detection:
      rust_code_mcp:
        current: "SHA-256 per file (O(n) scan)"
        planned: "Merkle tree (O(1) unchanged, O(log n) changes)"
        status: "In progress (merkle.rs added)"
      
      claude_context:
        method: "Merkle tree (production-validated)"
        performance: "Milliseconds for unchanged codebases"
        status: "Mature and proven"
    
    multi_language_support:
      rust_code_mcp:
        current: "Rust only"
        extensibility: "Needs tree-sitter parser abstraction"
        effort: "Medium (1-2 weeks per language)"
      
      claude_context:
        current: "JS, Python, Java, Go, Rust, TypeScript"
        extensibility: "Add tree-sitter parser (low effort)"
        status: "Production-ready multi-language"
    
    maturity:
      rust_code_mcp:
        status: "Active development"
        production_ready: "No (Qdrant not populated - critical bug)"
        strengths: "Innovative hybrid approach, local-first"
        needs: "Merkle tree, AST chunking, bug fixes"
      
      claude_context:
        status: "Production-deployed"
        production_ready: "Yes (multiple organizations using)"
        strengths: "Proven at scale, multi-language, VSCode extension"
        limitations: "Cloud dependencies, vector-only"

  recommendations:
    for_rust_code_mcp:
      immediate_priorities:
        - priority: 1
          task: "Fix Qdrant population bug"
          impact: "Critical - enables hybrid search"
          effort: "2-3 days"
          files:
            - "src/indexing/unified.rs"
            - "src/tools/search_tool.rs"
        
        - priority: 2
          task: "Implement Merkle tree change detection"
          impact: "High - 100-1000x speedup for unchanged codebases"
          effort: "1-2 weeks"
          files:
            - "src/indexing/merkle.rs (already started)"
            - "src/indexing/incremental.rs"
        
        - priority: 3
          task: "Switch to AST-first chunking"
          impact: "High - better chunk quality, semantic coherence"
          effort: "3-5 days"
          files:
            - "src/chunker/mod.rs"
            - "Use existing parser/mod.rs symbols"
      
      architectural_improvements:
        - "Add trait abstraction for Language parsers (multi-language)"
        - "Consider VectorStore trait for swappable backends"
        - "Add EmbeddingProvider enum (fastembed, OpenAI, Voyage)"
        - "Implement background file watching (notify crate)"
      
      unique_selling_points:
        - "Hybrid search (BM25 + vector) vs claude-context's vector-only"
        - "100% local privacy (no API calls, no cloud dependencies)"
        - "Zero ongoing costs (no subscriptions or API fees)"
        - "Self-contained binary (easier deployment)"
        - "Rust performance (faster than TypeScript)"
    
    for_claude_context_users:
      when_to_choose_rust_code_mcp:
        - "Proprietary or classified codebases (privacy required)"
        - "Air-gapped environments (no internet)"
        - "Cost-sensitive teams (no API budget)"
        - "Prefer self-hosted infrastructure"
        - "Need exact keyword search (BM25) in addition to semantic"
      
      when_to_stick_with_claude_context:
        - "Multi-language codebases (already supported)"
        - "Want managed services (Zilliz Cloud)"
        - "Need VSCode integration (extension available)"
        - "Prefer cloud-native deployment"
        - "API costs acceptable"
        - "Need production-proven solution now"

  modularity_comparison:
    rust_code_mcp:
      score: "8/10"
      structure: "11 feature-based modules with clear boundaries"
      reusability: "Good - modules can be used independently"
      testability: "Good - unit tests per module"
      maintainability: "Good - clear responsibilities, ~900 LOC per module avg"
      
      module_cohesion:
        - "High - each module has single responsibility"
        - "Parser only does parsing, Chunker only chunks"
        - "Security module is pure filtering"
      
      module_coupling:
        - "Low-medium - clear interfaces between layers"
        - "Some tight coupling at integration layer (intentional)"
      
      module_size_distribution:
        small: "6 modules (< 300 lines)"
        medium: "3 modules (300-800 lines)"
        large: "2 modules (800-1500 lines)"
        very_large: "0 modules"
      
      refactoring_ease: "Good - well-defined boundaries"
    
    claude_context:
      score: "9/10"
      structure: "3 packages with package-level isolation"
      reusability: "Excellent - core package is protocol-agnostic"
      testability: "Excellent - can test core without MCP or VSCode"
      maintainability: "Excellent - package boundaries enforce separation"
      
      package_cohesion:
        - "Very high - each package has distinct purpose"
        - "Core = business logic, MCP = protocol, Extensions = IDE"
      
      package_coupling:
        - "Low - packages depend only on public APIs"
        - "Core has zero knowledge of MCP or VSCode"
      
      refactoring_ease: "Excellent - change one package without affecting others"

summary:
  rust_code_mcp:
    architecture_strengths:
      - "Clean layered architecture with 11 well-defined modules"
      - "Hybrid search (BM25 + vector) provides best-of-both-worlds"
      - "100% local-first design (no cloud dependencies)"
      - "Merkle tree implementation for fast change detection (in progress)"
      - "Strong separation of concerns (parser, chunker, indexing, search)"
      - "Rust performance and safety guarantees"
    
    architecture_weaknesses:
      - "Single language support (Rust only, needs abstraction)"
      - "Tight coupling at tools layer (SearchTool depends on everything)"
      - "No embedded vector store option (Qdrant process required)"
      - "Critical bug: Qdrant not populated during indexing"
      - "Merkle tree not yet complete"
    
    code_organization_strengths:
      - "Cargo workspace with clear dependency management"
      - "Feature-based modules with ~900 LOC average size"
      - "XDG-compliant configuration"
      - "Comprehensive caching strategy (sled + Merkle + indices)"
    
    modularity_strengths:
      - "Low coupling between core modules (parser, chunker)"
      - "High cohesion within modules"
      - "Trait abstractions for extensibility"
      - "Clear data flow: parse → chunk → embed → index → search"
    
    deployment_flexibility:
      - "Excellent: standalone binary, library, Docker, cloud, air-gapped"
      - "Self-contained with local embeddings (fastembed)"
      - "Zero cloud dependencies"
    
    extensibility_assessment:
      - "Good: can add languages, embedding models, search algorithms"
      - "Needs: parser abstraction, VectorStore trait"
      - "Future: plugin system for custom tools"
  
  claude_context:
    architecture_strengths:
      - "Package-based monorepo with excellent separation"
      - "Production-validated Merkle tree implementation"
      - "Multi-language support via tree-sitter (6+ languages)"
      - "Pluggable embedding providers (OpenAI/Voyage/Ollama)"
      - "VSCode extension for IDE integration"
      - "Cloud-native with managed services"
    
    architecture_weaknesses:
      - "Vector-only search (no lexical/keyword search)"
      - "Cloud dependencies (APIs, Zilliz Cloud)"
      - "API costs scale with usage"
      - "Limited offline capability (unless Ollama)"
    
    code_organization_strengths:
      - "NPM workspace with shared dependencies"
      - "Clear package boundaries (core/mcp/extensions)"
      - "Testable units (core independent of protocol)"
    
    modularity_strengths:
      - "Excellent: core package is protocol-agnostic"
      - "Very low coupling between packages"
      - "High reusability (core can be used in different contexts)"
    
    deployment_flexibility:
      - "Excellent: NPM package, VSCode extension, cloud SaaS, self-hosted"
      - "Weak: air-gapped environments (needs workarounds)"
    
    extensibility_assessment:
      - "Excellent: multi-language, multi-provider, IDE integration"
      - "Proven: production deployment validates design"

key_insights:
  - "Both projects use tree-sitter for parsing (common foundation)"
  - "Both implement Merkle tree change detection (rust-code-mcp in progress)"
  - "Rust-code-mcp's hybrid search should outperform vector-only (45-50% vs 40% efficiency)"
  - "Claude-context's package structure provides better modularity than rust-code-mcp's modules"
  - "Rust-code-mcp is more suitable for privacy-sensitive/air-gapped deployments"
  - "Claude-context is more suitable for teams wanting managed services and multi-language support"
  - "Rust-code-mcp needs 3 critical fixes: Qdrant population, Merkle tree completion, AST chunking"
  - "Claude-context is production-ready, rust-code-mcp is not yet (due to bugs)"

use_case_recommendations:
  choose_rust_code_mcp_when:
    - "Privacy is critical (proprietary/classified codebases)"
    - "Air-gapped or offline environment"
    - "Zero cloud costs required"
    - "Need exact keyword search (BM25) in addition to semantic"
    - "Prefer Rust performance and safety"
    - "Self-hosting infrastructure"
    - "Willing to wait for bug fixes and completion"
  
  choose_claude_context_when:
    - "Multi-language codebase (JS, Python, Java, Go, Rust, TypeScript)"
    - "Want production-proven solution now"
    - "Prefer managed services (Zilliz Cloud)"
    - "Need VSCode integration"
    - "API costs acceptable"
    - "Cloud-native team culture"
    - "Open-source or non-sensitive codebase"